# **KS5005(KS5006)Keyestudio ESP32 37 in 1 Sensor Kit**

You need to look through the file“Preparation before class for
Python”first before get started with this kit.

![](media/97b7cfc0d5aca5dfa03193be40c4c776.png)


## 1. Description：

The Keyestudio ESP32 37 in 1 sensor kit mainly contains 37 commonly used
sensors and modules, an ESP32 board, an ESP32 expansion board and Dupont
wires.

All sensors and modules are fully compatible with the ESP32 expansion
board. You only need to stack the ESP32 mainboard onto the ESP32
expansion Board, and hook up them with Dupont wires, which is simple and
convenient.

To make you master the electronic knowledge, detailed tutorials,
schematic diagrams, wiring methods and test code are included. Through
these projects, you will have a better understanding about programming,
logic and electronics.

## 2. Kit：

(Note: the ESP32 board is included in the KS5005 kit；but not in the
KS5006 kit)

<table>
<tbody>
<tr class="odd">
<td>#</td>
<td>Picture</td>
<td>Name</td>
<td>QTY</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/099048eec26865fd9cc81d8c646c88e7.png" style="width:1.51319in;height:1.14236in" alt="KS6001 LED白发白模块" /></td>
<td>Keyestudio LED Module</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b83cfda6f21c26037d7f5bd5c403a2c7.png" style="width:1.55139in;height:1.17986in" alt="共阴RGB模块" /></td>
<td>Keyestudio Common Cathode RGB Module</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/9dd3ad6327733c3b06b61c22c302e22e.png" style="width:1.78889in;height:0.90139in" alt="_DSC2761" /></td>
<td>Keyestudio Traffic Lights Module</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/10e7df934f3065f87ecb0163a49b6a31.png" style="width:1.65556in;height:1.29514in" alt="_DSC2765" /></td>
<td>Keyestudio Active Buzzer</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/65cab276d08d6f29ba1a22359c0376f9.png" style="width:1.78264in;height:0.93958in" alt="8002b功放 喇叭模块" /></td>
<td>Keyestudio 8002b Audio Power Amplifier</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6f7cbd758d774713bd4181000d7efe1b.png" style="width:1.74514in;height:1.31389in" alt="单路按键模块" /></td>
<td>Keyestudio Button Module</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b9bd1f0923a6ab801d7b60d6da3d9a5b.png" style="width:1.40208in;height:1.05694in" alt="_DSC2725" /></td>
<td>Keyestudio Tilt Sensor</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6dcf2be9ac58a9c685ca2f64ffa32dfc.png" style="width:1.31181in;height:0.98819in" alt="KS6018人体红外热释电传感器" /></td>
<td>Keyestudio PIR Motion Sensor</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/986b897189c79895ffe626348359f634.png" style="width:1.55069in;height:1.13542in" alt="_DSC2741" /></td>
<td>Keyestudio Obstacle Avoidance Sensor</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a6ad46f7f2fe36fb33c048ea8210aaa7.png" style="width:1.44444in;height:1.09792in" alt="ks6009 6812 RGB LED 模块" /></td>
<td>Keyestudio 6812 RGB Module</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a2093df4945d05379824e2c56bb67b7e.png" style="width:1.56319in;height:1.09514in" alt="_DSC2733" /></td>
<td><p>Keyestudio NTC-MF52AT</p>
<p>Thermistor</p></td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/95346cf9c532dedd488d42b38a8b2649.png" style="width:1.49028in;height:1.16181in" alt="_DSC2738" /></td>
<td>Keyestudio Photoresistor</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f5d5feb5d7939f0b022a264608654e34.png" style="width:1.40347in;height:1.02431in" alt="19" /></td>
<td>Keyestudio Sound Sensor</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/39db0983ad86991ac3c1fa7e16e6b6b4.png" style="width:1.3875in;height:1.01806in" alt="_DSC2734" /></td>
<td><p>Keyestudio</p>
<p>Rotary Potentiometer</p></td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/907f79d7a0c3500820323343b0ef4681.png" style="width:1.41806in;height:1.05556in" alt="7" /></td>
<td>Keyestudio IR Receiver</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/8f7396128e7b0c2da1273aa050fa85df.png" style="width:1.43056in;height:1.08125in" alt="10" /></td>
<td>Keyestudio Reed Switch Sensor</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0ef1583b201c7944ba95ac97ee8a4ba8.png" style="width:1.55417in;height:1.16319in" alt="_DSC2760" /></td>
<td>Keyestudio Rotary Encoder Module</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a3ae6cf394df0cb2d30de18d1ea0b7ef.png" style="width:1.83403in;height:0.95069in" alt="摇杆模块" /></td>
<td>Keyestudio Joystick Module</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/af24d0e4bc9435881820504724ad3fcd.png" style="width:2.07778in;height:1.03542in" alt="8" /></td>
<td>Keyestudio HT16K33 8X8 Dot Matrix Module</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c1d8a69c763b04618d233b77fc97c4ab.png" style="width:2.07708in;height:0.99167in" alt="21" /></td>
<td>Keyestudio TM1650 4-Digit Tube Display</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/d1dd4137f10ccce92747bdd07e8738dd.png" style="width:1.99097in;height:0.67778in" alt="_DSC2750" /></td>
<td>Keyestudio Thin-film Pressure Sensor</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/aa2ea0a5040ec26cdc6f58256a2b31fc.png" style="width:2.07986in;height:1.05764in" alt="KS6072 keyestudio传感器 keyestudio 2021新款 DIY电子积木 DS1307时钟传感器模块 黑色环保" /></td>
<td>Keyestudio DS1307 Clock Sensor</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/43028b575a82be10e3ce23c40eb30061.png" style="width:2.07847in;height:1.15139in" /></td>
<td>Keyestudio SR01 Ultrasonic Sensor</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/46f3adcf9fc650b3a89bbde6d66f44ef.png" style="width:1.35in;height:1.33958in" alt="舵机" /></td>
<td>Servo</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a2a2f1b1f850ae58bc740b16d5eb396c.png" style="width:1.32847in;height:0.99931in" alt="电容触摸" /></td>
<td>Keyestudio Capacitive Sensor</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/5702e47b7ebc4b8556ee15f83d030f7f.png" style="width:1.37083in;height:1.03681in" alt="光折断" /></td>
<td>Keyestudio Photo Interrupter</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f70c9344f352a86cd809f3a2db44e3cb.png" style="width:1.42431in;height:1.06736in" alt="16.霍尔传感器" /></td>
<td>Keyestudio Hall Sensor</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/af90db3a116c8db533c7fea7e65fa99d.png" style="width:1.58958in;height:0.95278in" alt="火焰传感器" /></td>
<td>Keyestudio Flame Sensor</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/17d8f616b3d91fe7b7849fd3da8df695.png" style="width:1.38403in;height:1.04722in" alt="单路巡线" /></td>
<td>Keyestudio Line Tracking Sensor</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/ee4483f37a6f3609acdb661095f4b706.png" style="width:2.07847in;height:1.05in" alt="KS6029 MQ-2 模拟气体传感器" /></td>
<td>Keyestudio Analog Gas Sensor</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/04f2996e6e2b0d8d4b5158728a23e905.png" style="width:1.26667in;height:0.95694in" alt="33.温湿度" /></td>
<td>Keyestudio XHT11 Temperature and Humidity Sensor</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/d892bdfa25f3544ae28aa16d8b1b3c50.png" style="width:1.375in;height:1.03056in" alt="18B20温度传感器" /></td>
<td>Keyestudio 18B20 Temperature Sensor</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/cac2d3a8fd0e147e67dc6554caeef395.png" style="width:1.77708in;height:1.51528in" alt="KS6038 130电机驱动模块" /></td>
<td>Keyestudio 130 Motor</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/16f725d5da5b576a79e9299717d811d7.png" style="width:1.15903in;height:1.07778in" /></td>
<td>Fan</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/88abe96ca71fe1b89b23d92c890650ee.png" style="width:1.45in;height:0.95347in" alt="激光传感器" /></td>
<td>Keyestudio Laser Module</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b64cdb5749df7d2b7dd3719216c7aff3.png" style="width:1.40764in;height:1.00625in" alt="KS6048 水滴水蒸气传感器" /></td>
<td>Keyestudio Steam Sensor</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/3ee0bde62a5c8da6f89777cd47240e6c.png" style="width:1.66597in;height:0.81667in" alt="8" /></td>
<td>Keyestudio Relay Module</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0658d715437227acb99311e854f0c151.png" style="width:2.07917in;height:1.02917in" alt="RFID 新" /></td>
<td>Keyestudio RFID Module</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/7c0ba29f0bb560d79b15b1910033cc16.png" style="width:2.05833in;height:0.95417in" alt="4" /></td>
<td>Keyestudio ESP32 Development Board</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/28d1ac9f50fa08e66fa3f2d99d79e6fa.jpeg" style="width:1.98472in;height:1.51944in" alt="ks0465-1" /></td>
<td>Keyestudio ESP32-IO Expansion Board</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/10ccf14d80feba64bba0c1eacd02b09d.png" style="width:2.07222in;height:1.00139in" alt="11(2)" /></td>
<td>Keyestudio IR Remote Control</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.72917in;height:0.71736in" alt="USB线" /></td>
<td>USB Cable</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/33be6266ae36f54c9e7ffd044eae9320.png" style="width:2.07986in;height:0.64583in" /></td>
<td>F-F Dupont Wire</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/ade84f2ad63242834113a981be5d5ef3.png" style="width:1.21528in;height:1.87986in" /></td>
<td>White Card</td>
<td>1</td>
</tr>
<tr class="even">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/026296d61d87b05b5167c6425e8a0bd1.png" style="width:1.76736in;height:1.26597in" /></td>
<td>ABS RFID Key</td>
<td>1</td>
</tr>
<tr class="odd">
<td></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b65d826ca481982fed0212dba2957c7c.jpeg" style="width:1.57361in;height:1.13611in" alt="123" /></td>
<td>6 AA Battery Holder</td>
<td>1</td>
</tr>
</tbody>
</table>

## 3. Projects

There are 37 sensors and modules in this kit. Next, we will analyze and
introduce how they work step by step. Interface sensors with the ESP32
board and its expansion board, run test codes and observe experimental
phenomenon.

**Note: please wire up components according to the given connection
diagrams.**

**What’s more, wire up the power and signals correctly, otherwise,
sensors or modules will get damaged or no test results will be shown.**

### Project 1: Hello World

**Overview**

In this project, we will make an experiment to light up the white LED
module. The high and low levels can be controlled by programming, then
the state of the LED can be controlled.

**Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/56053f7126905c6def63919c661d5c0a.jpeg" style="width:1.56875in;height:0.76528in" alt="ks0413-3(1)" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/3bdcc62cfa661d2b860a76e28537e21e.png" style="width:1.41667in;height:0.76042in" /></td>
</tr>
<tr class="even">
<td>ESP32*1</td>
<td>USB Cable *1</td>
</tr>
</tbody>
</table>

**Wire Up：**

Connect the ESP32 to your computer

![](media/56053f7126905c6def63919c661d5c0a.jpeg)

**Running code online：**

To run the ESP32 online, you need to connect the ESP32 to the computer,
which allows you to compile or debug programs using Thonny software.  

Advantages:

1\. You can use the Thonny software to compile or debug programs.

2.Through the "Shell" window, you can view error messages and output
results generated during the running of the program as well as query
related function information online to help improve the program.  

Disadvantages:

1.  To run the ESP32 online, you must connect the ESP32 to a computer
    and run it with the Thonny software.  

<!-- end list -->

2.  If the ESP32 is disconnected from the computer , when they
    reconnect, the program won't run again.  

<!-- end list -->

1.  Open Thonny，and click![](media/6388aa0daa514f9325fb07fd5ab6749b.png)“Open...”
    
    ![](media/319b34bcc43d038d633af9acba0c198c.png)

2.  Click“This computer”in the new pop-up window.
    
    ![](media/5bdbc66ef89b41a53e46696c07b2c282.png)

Select“Project\_01\_HelloWorld.py”,click“Open”. The code used in this
tutorial is saved in the file KS5005(KS5006)Keyestudio ESP32 37 in
1 Sensor Kit\\Windows\\MicroPython\\2.ESP32\_code\_MicroPython.

You can move the code to anywhere, for example,we can save the
**2.ESP32\_code\_MicroPython in the** Disk(D), the route is
**D:\\2.ESP32\_code\_MicroPython.**（The code in this tutorial is saved
in the Disk(D) on your computer）

![](media/f26168c6fbf3638ab82e8ab5fcb8abba.png)

![](media/42e7ab8155f0df7a56ac57ab5ed97d00.png)

Click![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”to execute the
program“Hello World\!”, "Welcome Keyestudio" , which will be printed
in the“Shell”window.

![](media/c87d49e498df065dd42dbf32c2eec7ad.png)

**Exit running online**

When running online, click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png) “Stop /Restart
Backend”or press “Ctrl+C”on the Thonny to exit the program.  

![](media/db5de333b3cd58609dcca10a9382155c.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>print("Hello World!")</p>
<p>print("Welcome Keyestudio")</p></td>
</tr>
</tbody>
</table>

### Project 2: Lighting up LED

![](media/ce8d61c97eb89c94c05cc1f6299316b5.jpeg)

**Overview**

In this project, we will make an experiment to light up the white LED
module. The high and low levels can be controlled by programming, then
the state of the LED can be controlled.

**Working Principle**

The two circuit diagrams are given. The left one is wrong wiring-up
diagram. Why? Theoretically, when the S terminal outputs high levels,
LED will receive the voltage and light up.

Due to limitation of IO ports of Pico board, weak current can’t make LED
brighten.

The right one is correct wiring-up diagram. GND and VCC are powered up.
When the S terminal is a high level, the triode Q1 will be connected and
LED will light up(note: current passes through LED and R3 to reach GND
by VCC not IO ports). Conversely, when the S terminal is a low level,
the triode Q1 will be disconnected and LED will go off.

The triode Q1 is equal to a switch and R1 and R3 stand for limited
resistors which can curb the size of current to prevent from burning out
components

![](media/d205e9ad7c33cc55909cb1d652d42ad7.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.20833in;height:0.56042in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.40903in;height:1.07917in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/12ecb079cf6481a6f0f04d6b7bb31fd8.png" style="width:0.70417in;height:0.93889in" alt="白色LED模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.88056in;height:0.32083in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.83611in;height:0.44792in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Purple LED Module*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**Wiring Diagram**

![](media/fed849dd5952f3b94a591d5bc5e64267.png)

**Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>led = Pin(0, Pin.OUT)# Build an LED object, connect the external LED light to pin 0, and set pin 0 to output mode</p>
<p>while True:</p>
<p>led.value(1)# turn on led</p>
<p>time.sleep(1)# delay 1s</p>
<p>led.value(0)# turn off led</p>
<p>time.sleep(1)# delay 1s</p></td>
</tr>
</tbody>
</table>

**Code Explanation**

**Machine** module is indispensable, we will use **import machine** or
**from machine import...** to program pico with microPython.

time.sleep() function is used to set delayed time, as
**time.sleep(0.01),** which means, the delayed time is 10ms.

1.  **led = Pin(0, Pin.OUT)**，created a pin example and we name **led.**
    
    **0** is indicative of connected pin GP0，**Pin.OUT represents output
    mode**， can use **.value() to output high levels**
    (3.3V)**led.value(1) or low levels** (0V)**led.value(0)**。
    
    **import machine** is used to import modules. When creating pins
    examples, it will change into **led = machine.Pin(0,
    machine.Pin.OUT)**
    
    **Test Result：**
    
    Wire up and click ![](media/da852227207616ccd9aff28f19e02690.png). Then LED will falsh.
    Press “Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png) to exit the program

### Project 3: Traffic Lights Module

![](media/e191c790f251715b418bcfd39a32917f.jpeg)

**Overview**

In this lesson, we will learn how to control multiple LED lights and
simulate the operation of traffic lights.

Traffic lights are signal devices positioned at road intersections,
pedestrian crossings, and other locations to control flows of traffic.

In this kit, we will use the traffic light module to simulate the
traffic light.

**Working Principle**

In previous lesson, we already know how to control an LED. In this part,
we only need to control three separated LEDs. Output high levels to the
signal R(3.3V), then the red LED will be on.

![](media/1479f32d51a02c2230cb535197093d4c.png)

**Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.20833in;height:0.56042in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.40903in;height:1.07917in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6ff6e93b37472de2695aefed0939a14e.png" style="width:0.55833in;height:1.11736in" alt="交通灯模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/fc3fd9c0110b04d1af77a2ff8c01a10a.png" style="width:0.95208in;height:0.39931in" alt="5p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.85972in;height:0.36875in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td><p>ESP32 Expansion</p>
<p>Board*1</p></td>
<td>Keyestudio Traffic Lights Module*1</td>
<td>5P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**Wiring Diagram**

![](media/cecade99c652fe14ea7547b80849f5b7.png)

**Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>import machine</p>
<p>import time</p>
<p>led_red = machine.Pin(15, machine.Pin.OUT)</p>
<p>led_yellow = machine.Pin(2, machine.Pin.OUT)</p>
<p>led_green = machine.Pin(0, machine.Pin.OUT)</p>
<p>while True:</p>
<p>led_green.value(1) # green light turn on</p>
<p>time.sleep(5) # delay 5s</p>
<p>led_green.value(0) # green light turn off</p>
<p>for i in range(3): # yellow light blinks 3 times</p>
<p>led_yellow.value(1)</p>
<p>time.sleep(0.5)</p>
<p>led_yellow.value(0)</p>
<p>time.sleep(0.5)</p>
<p>led_red.value(1) # red light turn on</p>
<p>time.sleep(5) # delay 5s</p>
<p>led_red.value(0) #red light turn off</p></td>
</tr>
</tbody>
</table>

**Code Explanation**

Create pins, set pins mode and delayed functions.

We use the **for** loop.

The simplest form is **for i in range()**.

In the code, we used range(3), which means the variable i starts from 0,
increase 1 for each time, to 2.

**Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png). We will see that
the green LED will be on for 5s then off, the yellow LED will flash for
3s then go off and the red one will be on for 5s then off.
Press“Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)to exit the program.

### Project 4: Laser Sensor

![](media/d5d84e9d26d2cc89772a05eed6340bc0.jpeg)

**Description**

Lasers are widely used to cut, weld, surface treat, and more on specific
materials. The energy of the laser is very high. The toy laser pointer
may cause glare to the human eye, and it may cause retinal damage for a
long time. my country also prohibits the use of laser to illuminate the
aircraft.

**Working Principle**

The laser head sensor module is mainly composed of a laser head with a
light-emitting die, a condenser lens, and a copper adjustable sleeve.

We can see the circuit schematic diagram of this module which is very
similar to the LED we have learned. They are all driven by triodes. A
high-level digital signal is directly input at the signal end, then the
sensor will start to work; if inputting low levels, the sensor won’t
work.

Note: don’t point an laser emitter at eyes of people.

![](media/25be2840ca059e6e6953a3c3646649dc.png)

**Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/88abe96ca71fe1b89b23d92c890650ee.png" style="width:1.07708in;height:0.70833in" alt="激光传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.88056in;height:0.32083in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.83611in;height:0.44792in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Laser Module*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**Wiring Diagram**

![](media/73060fc0934dd3d40c8fd7062b6173c9.png)

**Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>laser = Pin(0, Pin.OUT)# Build a laser object, connect the laser to pin 0, and set pin 0 to output mode</p>
<p>while True:</p>
<p>laser.value(1) # Turn on the laser</p>
<p>time.sleep(2) # dalay 2s</p>
<p>laser.value(0) # Turn off the laser</p>
<p>time.sleep(2) # delay 2s</p></td>
</tr>
</tbody>
</table>

**Code Explanation**

Please refer to project 2 above for the code setting instructions.

**Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png), the code starts
executing, we will see that the laser tube on the module emits a red
laser signal for 2 seconds, and stops emitting a red laser signal for 2
seconds. Press “Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

### Project 5: Breathing LED

![](media/25107e92a36e701f271b2371359f2679.jpeg)

1.  **Overview**

A“breathing LED”is a phenomenon where an LED's brightness smoothly
changes from dark to bright and back to dark, continuing to do so and
giving the illusion of an LED“breathing. This phenomenon is similar to a
lung breathing in and out. So how to control LED’s brightness? We need
to take advantage of PWM.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f0ef7a5a2e7eebb09e91f73cb2a6caf3.png" style="width:0.64931in;height:0.86528in" alt="白色LED模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Purple LED Module*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/fed849dd5952f3b94a591d5bc5e64267.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>import time</p>
<p>from machine import Pin,PWM</p>
<p>#The way that the ESP32 PWM pins output is different from traditionally controllers.</p>
<p>#It can change frequency and duty cycle by configuring PWM’s parameters at the initialization stage.</p>
<p>#Define GPIO 0’s output frequency as 10000Hz and its duty cycle as 0, and assign them to PWM.</p>
<p>pwm =PWM(Pin(0,Pin.OUT),10000,0)</p>
<p>try:</p>
<p>while True:</p>
<p>#The range of duty cycle is 0-1023, so we use the first for loop to control PWM to change the duty</p>
<p>#cycle value,making PWM output 0% -100%; Use the second for loop to make PWM output 100%-0%.</p>
<p>for i in range(0,1023):</p>
<p>pwm.duty(i)</p>
<p>time.sleep_ms(1)</p>
<p>for i in range(0,1023):</p>
<p>pwm.duty(1023-i)</p>
<p>time.sleep_ms(1)</p>
<p>except:</p>
<p>#Each time PWM is used, the hardware Timer will be turned ON to cooperate it. Therefore, after each use of PWM,</p>
<p>#deinit() needs to be called to turned OFF the timer. Otherwise, the PWM may fail to work next time.</p>
<p>pwm.deinit()</p></td>
</tr>
</tbody>
</table>

**5.Test Result**

Wire up and power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current
script”, the code starts executing, we will see that the LED on the
module gradually gets dimmer then brighter, cyclically, like human
breathe. Press“Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

### Project 6: RGB Module

![](media/b3515a7e0340f391bef256c9ed6ccd4b.jpeg)

1.  **Overview**

Among these modules is a RGB module. It adopts a F10-full color RGB
foggy common cathode LED. We connect the RGB module to the PWM port of
MCU and the other pin to GND(for common anode RGB, the rest pin will be
connected to VCC). So what is PWM?

PWM is a means of controlling the analog output via digital means.
Digital control is used to generate square waves with different duty
cycles (a signal that constantly switches between high and low levels)
to control the analog output.In general, the input voltages of ports are
0V and 5V. What if the 3V is required? Or a switch among 1V, 3V and
3.5V? We cannot change resistors constantly. For this reason, we resort
to PWM.

![](media/bbcfcb9ae56abb7e80ee587246fc4be9.GIF)

For Arduino digital port voltage outputs, there are only LOW and HIGH
levels, which correspond to the voltage outputs of 0V and 5V
respectively. You can define LOW as“0”and HIGH as“1’, and let the
Arduino output five hundred‘0’or“1”within 1 second. If output five
hundred‘1’, that is 5V; if all of which is‘0’,that is 0V; if output 250
01 pattern, that is 2.5V.

This process can be likened to showing a movie. The movie we watch are
not completely continuous. Actually, it generates 25 pictures per
second, which cannot be told by human eyes. Therefore, we mistake it as
a continuous process. PWM works in the same way. To output different
voltages, we need to control the ratio of 0 and 1. The more‘0’or‘1’
output per unit time, the more accurate the control.

2.  **Working Principle**

For our experiment, we will control the RGB module to display different
colors through three PWM values.

![](media/71e990d503b6f1822379091a37f58a6b.jpeg)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/51729b3ba2184cf0ca0d3242199731ad.png" style="width:0.65972in;height:0.88125in" alt="共阴RGB模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:1.03264in;height:0.40278in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio DIY Common Cathode RGB *1</td>
<td>4P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/e684c10368af661546702f94e0a495f3.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># import Pin, PWM and Random function modules.</p>
<p>from machine import Pin, PWM</p>
<p>from random import randint</p>
<p>import time</p>
<p>#Configure ouput mode of GPIO0, GPIO2 and GPIO15 as PWM output and PWM frequency as 10000Hz.</p>
<p>pins = [0, 2, 15]</p>
<p>pwm0 = PWM(Pin(pins[0]),10000)</p>
<p>pwm1 = PWM(Pin(pins[1]),10000)</p>
<p>pwm2 = PWM(Pin(pins[2]),10000)</p>
<p>#define a function to set the color of RGBLED.</p>
<p>def setColor(r, g, b):</p>
<p>pwm0.duty(1023-r)</p>
<p>pwm1.duty(1023-g)</p>
<p>pwm2.duty(1023-b)</p>
<p>try:</p>
<p>while True:</p>
<p>red = randint(0, 1023)</p>
<p>green = randint(0, 1023)</p>
<p>blue = randint(0, 1023)</p>
<p>setColor(red, green, blue)</p>
<p>time.sleep_ms(200)</p>
<p>except:</p>
<p>pwm0.deinit()</p>
<p>pwm1.deinit()</p>
<p>pwm2.deinit()</p></td>
</tr>
</tbody>
</table>

3.  **Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing, we will see that the RGB LED on the module
starts to display random colors. Press“Ctrl+C”or click
![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

### Project 7: Button Sensor

![](media/4d5f6ea741d1e346e03f6efe7cfc9d2d.jpeg)

1.  **Overview**

In this kit, there is a Keyestudio single-channel button module, which
mainly uses a tact switch and comes with a yellow button cap.

In previous lessons, we learned how to make the pins of our single-chip
microcomputer output a high level or low level. In this experiment, we
will read the high level (3.3V) and low level (0V).

We can determine whether the button on the sensor is pressed by reading
the high and low level of the S terminal on the sensor.

2.  **Working Principle**

The button module has four pins. The pin 1 is connected to the pin 3 and
the pin 2 is linked with the pin 4. When the button is not pressed, they
are disconnected. Yet, when the button is pressed, they are connected.
If the button is released, the signal end is high level.

![](media/a51debfc8a38d0d5729d1da394f95ca5.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/efcc7b40d80043b7b1f90ceaa8d73639.png" style="width:0.63611in;height:0.84861in" alt="单路按键模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.91736in;height:0.33403in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.99167in;height:0.53125in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio DIY Button Module*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/395caba95f49d582d7fd36cacbf44a7c.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>button = Pin(15, Pin.IN, Pin.PULL_UP)</p>
<p>while True:</p>
<p>if button.value() == 0:</p>
<p>print("You pressed the button!") #Press to print the corresponding information.</p>
<p>else:</p>
<p>print("You loosen the button!")</p>
<p>time.sleep(0.1) #delay 0.1s</p></td>
</tr>
</tbody>
</table>

3.  **Code Explanation**

**button = Pin(15, Pin.IN, Pin.PULL\_UP),** we define the pin of the
button as GP15 and set to PULL-UP mode

We can use **button = Pin(15, Pin.IN) to set INPUT mode,** at this time,
the pins are in high resistance state.

1.  **button.value(),** read levels of buttons. Function returns High or
    Low

2.  **if..else.. sentence,** when the logic judge is TRUE, the code
    under the if will be activated; otherwise, the code udder the else
    will be activated.

3.  When ESP32 detects the button pressed, the signal end is low level
    (GP 15 is low level). **button.value() is 0.** If the ESP32 detects
    the button unpressed, **button.value()** is 1 and else sentence will
    be activated.

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing, the string will be displayed on the ”Shell“
window. When the button is pressed, the ”Shell“ window will show“You
pressed the button\!”；when the button is released，the ”Shell“ window
will show“You Loosen the button”; as shown below. Press “Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/ba199239c85c395f36e42612246288eb.png)

### Project 8: Capacitive Sensor

![](media/794f73317cd5349345e92cebb5ccb410.jpeg)

1.  **Description**

In this kit, there is a capacitive touch module which mainly uses a
TTP223-BA6 chip. It is a touch detection chip, which provides a touch
button, and its function is to replace the traditional button with a
variable area button. When we power on, the sensor needs about 0.5
seconds to stabilize. Do not touch the keys during this time period. At
this time, all functions are disabled, and self-calibration is always
performed. The calibration period is about 4 seconds. We display the
test results in the shell.

![](media/7fe7f9d2bdf7b9b25e708c52d7dda66d.png)

**2. Working Principle**

When our fingers touch the module, the signal S outputs high levels, the
red LED on the module flashes. We can determine if the button is pressed
or not by reading high and low levels on the sensor.

![](media/7fe7f9d2bdf7b9b25e708c52d7dda66d.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0f78442477f8d2a5f5ef81974e03ee1c.png" style="width:0.84722in;height:0.6375in" alt="电容触摸" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.91736in;height:0.33403in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.99167in;height:0.53125in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Capacitive Module</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/56ba673521d6b8e398b321382b402732.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>touch = Pin(15, Pin.IN, Pin.PULL_UP)</p>
<p>while True:</p>
<p>if touch.value() == 1:</p>
<p>print("You pressed the button!") #Press to print the corresponding information.</p>
<p>else:</p>
<p>print("You loosen the button!")</p>
<p>time.sleep(0.1) #delay0.1s</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

When we touch the sensor, the Shell monitor will show“You pressed the
button\!”, if not,“You loosen the button\!”will be shown on the monitor.

**7. Test Result**

Connect the wires according to the experimental wiring diagram and
poweron. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”, the code
starts executing, the string will be displayed in the ”Shell“ window.
when the button is pressed, the red LED lights up and val is 1.Then the
shell shows“You pressed the button\!”; if the button is released, the
red LED is off and val is 0;“You loosen the button\!”will be displayed,
as shown below. Press“Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/986ac5c456aa58948d7985bfd54b44b5.png)

### Project 9: Obstacle Avoidance Sensor

![](media/e6dda88bb6faf8fc06d81361b7f48a3d.jpeg)

1.  **Overview**

In this kit, there is a Keyestudio obstacle avoidance sensor, which
mainly uses an infrared emitting and a receiving tube. In the
experiment, we will determine whether there is an obstacle by reading
the high and low level of the S terminal on the sensor.

**2. Working Principle**

NE555 circuit provides IR signals with frequency to the emitter TX, then
the IR signals will fade with the increase of transmission distance. If
encountering the obstacle, it will be reflected back.

When the receiver RX meets the weak signals reflected back, the
receiving pin will output high levels, which indicates the obstacle is
far away. On the contrary, it the reflected signals are stronger, low
levels will be output, which represents the obstacle is close. There are
two potentiometers on the module, and one is for adjusting emission
power, another one is for receiving
frequency.![](media/f32ebd19bd8e893ab6c865f83b274900.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b62846d9a80a7e7aed5ffbef0caedf7c.png" style="width:0.64167in;height:0.92083in" alt="避障传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Obstacle Avoidance Sensor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/1c80fc2e1d7c038f0e105164090b97da.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>sensor = Pin(15, Pin.IN)</p>
<p>while True:</p>
<p>if sensor.value() == 0:</p>
<p>print("There are obstacles")</p>
<p>else:</p>
<p>print("All going well")</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation：**

The setting method is similar to project 7

**Note:**

Connect the wires according to the connection diagram. After powering
on, we start to adjust the two potentiometers to sense distance.

1.  Adjust the potentiometer transmitting power. Make the P LED at the
    critical point of ON and OFF states.

2\. Adjust the potentiometer receiving frequency. Rotate it clockwise,
the frequency will increase. Make the S LED at the critical point of ON
and OFF states, then the 38KHz square wave can be produced.

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing, the string will be displayed in the ”Shell“
window. When the sensor detects the obstacle, sensor.value() is 0，the
shell will show“There are obstacles”, if the obstacle is not detected,
sensor.value () is 1,“All going well”will be shown, as shown below.
Press “Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to
exit the program.

![](media/86fc39da5df74b72325d5daddff5af70.png)

### Project 10: Line Tracking Sensor

![](media/56a1aed8ccadf21894486e3e464740d1.jpeg)

1.  **Description**

In this kit, there is a DIY electronic building block single-channel
line tracking sensor which mainly uses a TCRT5000 reflective black and
white line recognition sensor element.

In the experiment, we judge the color (black and white) of the object
detected by the sensor by reading the high and low levels of the S
terminal on the module; and display the test results on the shell.

**2. Working Principle**

![](media/b4bec738ca3565a2ce3a274bfec4a57a.png)When a black or no object is detected, the
signal terminal will output high levels; when white object is detected,
the signal terminal is low level; its detection height is 0-3cm. We can
adjust the sensitivity by rotating the potentiometer on the sensor. When
the potentiometer is rotated, the sensitivity is best when the red LED
on the sensor is at the critical point between off and on.

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/3538e48e4603a0afb9ae18197769c3ef.png" style="width:0.89375in;height:0.67569in" alt="单路巡线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Line Tracking Sensor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/8bf3cd4119768830839818cb8b9cee54.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>sensor = Pin(15, Pin.IN, Pin.PULL_UP)</p>
<p>while True:</p>
<p>if sensor.value() == 0:</p>
<p>print("0 White") #Press to print the corresponding information.</p>
<p>else:</p>
<p>print("1 Black")</p>
<p>time.sleep(0.1) #delay 0.1s</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

The setting method is similar to project 7.

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing, the string and data will be displayed in the
”Shell“ window. when the sensor doesn’t detect an object or detects a
black object, the val is 1, and the shell will display "Black" ; when a
white object (can reflect light) is detected, the val is 0, and the
shell displays "White" , as shown below. Press “Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/ffb86d4f5e9ba5be05aae39e633f169b.png)

### Project 11: Photo Interrupter

![](media/20519af325d65d055bd8b70c1475438e.jpeg)

**1. Description**

This kit contains a photo interrupter which mainly uses 1 ITR-9608
photoelectric switch. It is a photoelectric switch optical switch
sensor.

**2. Working Principle**

When the paper is put in the slot, C is connected with VCC and the
signal end S of the sensor are high levels; then the red LED will be
off. Otherwise, the red LED will be on.

![](media/2c2608b83d7105702560cdfe4a394dde.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/1fd8fab1f649d7f3f7711afd088046d3.png" style="width:0.90347in;height:0.68333in" alt="光折断" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Photo Interrupter*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/8444b72b5a68234acc69a6a3e16b8449.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>sensor = Pin(15, Pin.IN, Pin.PULL_UP)</p>
<p>lastState = 0</p>
<p>PushCounter = 0</p>
<p>while True:</p>
<p>State = sensor.value()</p>
<p>if State != lastState:</p>
<p>if State == 1:</p>
<p>PushCounter += 1</p>
<p>print(PushCounter) #Press to print the corresponding information.</p>
<p>lastState = State</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

**Logic setting :**

<table>
<tbody>
<tr class="odd">
<td>Initial Setting</td>
<td>Set PushCounter to 0</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>Set State to 0 (value of the sensor)</td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>Set lastState to 0</td>
<td></td>
</tr>
<tr class="even">
<td>when an object enters the slot</td>
<td>lastState is 0，State turns into 1; lastState turns into 1</td>
<td><p>Set PushCounter to PushCounter+1</p>
<p>print the value of PushCounter</p></td>
</tr>
<tr class="odd">
<td>when the object leaves the slot</td>
<td>lastState is 1，State becomes 0，two data are not equal，lastState turns into 0.</td>
<td><p>PushCounterdoesn’t change;</p>
<p>Don’t print the value of PushCounter</p></td>
</tr>
<tr class="even">
<td>When the object goes through this slot again</td>
<td>lastState is 0, State becomes 1，two data are not equal，lastState turns into 1.</td>
<td><p>Set PushCounter to PushCounter+1</p>
<p>And print the value of PushCounter</p></td>
</tr>
<tr class="odd">
<td>When the object leaves this slot again</td>
<td>lastState is 1，State turns into 0，two data are not equal lastState turns into 0</td>
<td><p>PushCounter doesn’t change;</p>
<p>Don’t print the PushCounter value</p></td>
</tr>
</tbody>
</table>

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing, data will be displayed in the ”Shell“ window.
Every time when the object passes through the slot of the sensor, the
PushCounter data will increase by 1 continuously, as shown below. Press
“Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit
the program.

![](media/ca50b68405bcd20971b720df4cae8f69.png)

### Project 12: Tilt Module

![](media/9d4fcf498d8943539935d0f9638f22eb.jpeg)

1.  **Overview**

In this kit, there is a Keyestudio tilt sensor. The tilt switch can
output signals of different levels according to whether the module is
tilted. There is a ball inside. When the switch is higher than the
horizontal level, the switch is turned on, and when it is lower than the
horizontal level, the switch is turned off. This tilt module can be used
for tilt detection, alarm or other detection.

**2. Working Principle**

The working principle is pretty simple. When pin 1 and 2 of the ball
switch P1 are connected, the signal S is low level and the red LED will
light up; when they are disconnected, the pin will be pulled up by the
4.7K R1 and make S a high level, then LED will be off.

![](media/7b5da31ecdd90419d5b3326eebdb14e7.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f647184fbb638f8e5a92a388ee1a6f2b.png" style="width:0.72847in;height:0.96944in" alt="倾斜传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Tilt Sensor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/0303daa7c70c79e2e1784f9e23693425.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>TiltSensor = Pin(15, Pin.IN)</p>
<p>while True:</p>
<p>value = TiltSensor.value()</p>
<p>print(value, end = " ")</p>
<p>if value== 0:</p>
<p>print("The switch is turned on")</p>
<p>else:</p>
<p>print("The switch is turned off")</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing, the string and the data will be displayed in
the ”Shell“ window. When the tilt module is inclined to one side, the
red LED on the module will be off and the Shell“ window will display“1
The switch is turned off”. In contrast, if you make it incline the other
side, the red LED will light up and the monitor will display“0 The
switch is turned on”, as shown below. Press “Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/a08940e31dfd94613a6c5c45d94879fc.png)

### Project 13: Hall Sensor

![](media/3fa2bf365868256a8c9fe4f32c883c91.jpeg)

1.  **Description**

In this kit, there is a Hall sensor which mainly adopts a A3144 linear
Hall element. The element P1 is composed of a voltage regulator, a Hall
voltage generator, a differential amplifier, a Schmitt trigger, a
temperature compensation circuit and an open-collector output stage. In
the experiment, we use the Hall sensor to detect the magnetic field and
display the test results on the shell.

**2. Working Principle**

When the sensor detects no magnetic field or a north pole magnetic
field, the signal terminal will be high level; when it senses a south
pole magnetic field, the signal terminal will be low levels.

The stronger the magnetic field strength is, induction distance is
longer.

![](media/e9dcd0f7f384f9233a0f227c7a8d3744.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/bf9962d91f7f917f4212686ef6962fd3.png" style="width:0.89097in;height:0.66806in" alt="16.霍尔传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Hall Sensor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/335c913c8869defe1f0c8e8d3a801913.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>hall = Pin(15, Pin.IN)</p>
<p>while True:</p>
<p>value = hall.value()</p>
<p>print(value, end = " ")</p>
<p>if value == 0:</p>
<p>print("A magnetic field")</p>
<p>else:</p>
<p>print("There is no magnetic field")</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing, the string and the data will be displayed on
the Shell. when the sensor detects no magnetic fields or the north pole
magnetic field, Shell will show“1 There is no magnetic field”and the LED
on the sensor will be off; When it detects the south pole magnetic
field, the Shell will show“0 A magnetic field”and the LED on the sensor
will be on, as shown below. Press “Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/56a3d161f47532ee9f26c5daddeddd7e.png)

### Project 14: Reed Switch Module

![](media/2a699e913fa52d9acff4b0e4a8188540.png)

1.  **Overview**

In this kit, there is a Keyestudio reed switch module, which mainly uses
a MKA10110 green reed component.

The reed switch is the abbreviation of the dry reed switch. It is a
passive electronic switch element with contacts.

It has the advantages of simple structure, small size and easy control.
Its shell is a sealed glass tube with two iron elastic reed electric
plates.

In the experiment, we will determine whether there is a magnetic field
near the module by reading the high and low level of the S terminal on
the module; and, we display the test result in the shell.

**2. Working Principle**

![](media/a4a9a00f86be808be0a9c784a6960cd6.jpeg)

In normal conditions, the glass tube in the two reeds made of special
materials are separated. When a magnetic substance close to the glass
tube, in the role of the magnetic field lines, the pipe within the two
reeds are magnetized to attract each other in contact, the reed will
suck together, so that the junction point of the connected circuit
communication.

After the disappearance of the outer magnetic reed because of their
flexibility and separate, the line is disconnected. The sensor uses this
characteristic to build a circuit to convert magnetic field signal into
high and low level signal.  

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/92c44afcc82bb13a14e8438646670cc6.png" style="width:0.66875in;height:0.88681in" alt="干簧管模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Reed Switch Module*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/45cb30739b7c6518fe1591142aabbf2f.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>ReedSensor = Pin(15, Pin.IN)</p>
<p>while True:</p>
<p>value = ReedSensor.value()</p>
<p>print(value, end = " ")</p>
<p>if value == 0:</p>
<p>print("A magnetic field")</p>
<p>else:</p>
<p>print("There is no magnetic field")</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script
and power on. When the sensor detects a magnetic field, val is 0 and the
red LED of the module lights up, "0 A magnetic field" will be displayed;
when no magnetic field is detected, val is 1, and the LED on the module
goes out, "1 There is no magnetic field" will be shown, as shown below.
Press “Ctrl+C” or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend” to
exit the program.

![](media/f44214d63a5974544ca996f93764b550.png)

### Project 15: PIR Motion Sensor

![](media/d58ba7b9b4a0115b07cbb1c871ef8ec9.jpeg)

1.  **Overview**

In this kit, there is a Keyestudio PIR motion sensor, which mainly uses
an RE200B-P sensor elements. It is a human body pyroelectric motion
sensor based on pyroelectric effect, which can detect infrared rays
emitted by humans or animals, and the Fresnel lens can make the sensor's
detection range farther and wider.

In the experiment, we determine if there is someone moving nearby by
reading the high and low levels of the S terminal on the module. The
detected results will be displayed on the Shell.

**2. Working Principle**

The upper left part is voltage conversion(VCC to 3.3V). The working
voltage of sensors we use is 3.3V, therefore we can’t use 5V directly.
The voltage conversion circuit is needed.

When no person is detected or no infrared signal is received, and pin 1
of the sensor outputs low level. At this time, the LED on the module
will light up and the MOS tube Q1 will be connected and the signal
terminal S will detect Low levels.

When one is detected or an infrared signal is received, and pin 1 of the
sensor outputs a high level. Then LED on the module will go off, the MOS
tube Q1 is disconnected and the signal terminal S will detect high
levels.

![](media/e62f4d614ab7e67ac373576d7ff96fee.png)

2.  **Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/8712c267aff99cc16c2071398d6632af.png" style="width:0.63125in;height:0.83958in" alt="人体红外热释传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio PIR Motion Sensor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/6e57df420ca5d0dcc6f87467bb0295db.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>PIR = Pin(15, Pin.IN)</p>
<p>while True:</p>
<p>value = PIR.value()</p>
<p>print(value, end = " ")</p>
<p>if value == 1:</p>
<p>print("Some body is in this area!")</p>
<p>else:</p>
<p>print("No one!")</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing, the string and the data will be displayed in
the ”Shell“ window. When the sensor detects someone nearby, value is 1,
the LED will go off and the ”Shell“ window will show“1 Somebody is in
this area\!”. On the contrary, the value is 0, the LED will go up and“0
No one\!”will be shown, as shown below. Press “Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend” to exit the program.

![](media/35150d4268fa4716df8624845567f888.png)

### Project 16: Active Buzzer

![](media/f4cc23dc8ed28d408e5a119855e19aa2.jpeg)

1.  **Overview**

In this kit, it contains an active buzzer module and a power amplifier
module (the principle is equivalent to a passive buzzer). In this
experiment, we control the active buzzer to emit sounds. Since it has
its own oscillating circuit, the buzzer will automatically sound if
given large voltage.

**2. Working Principle**

From the schematic diagram, the pin of buzzer is connected to a resistor
R2 and another port is linked with a NPN triode Q1. So, if this triode
Q1 is powered, the buzzer will sound.

If the base electrode of the triode connected to the R1 resistor is a
high level, the triode Q1 will be connected.If the base electrode is
pulled down by the resistor R3, the triode is disconnected.

When we output a high level from the IO port to the triode, the buzzer
will emit sounds; if outputting low levels, the buzzer won’t emit
sounds.

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a5e355d0fd3c9b18c7684a9a2b99f0a5.png" style="width:0.70625in;height:0.94167in" alt="有源蜂鸣器模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Active Buzzer*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/44508746060c5df3544ab2d84b2482bf.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>buzzer = Pin(15, Pin.OUT)</p>
<p>while True:</p>
<p>buzzer.value(1)</p>
<p>time.sleep(1)</p>
<p>buzzer.value(0)</p>
<p>time.sleep(1)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

In the experiment, we set the pin to GPIO15. When setting to high, the
active buzzer will beep; when setting to low, the active buzzer will
stop emitting sounds.

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The active buzzer will emit sound for 1
second, and stop for 1 second. Press “Ctrl+C” or click
![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend” to exit the program.

### Project 17: 8002b Audio Power Amplifier

![](media/6e8569df97b72e866488a6f414f9e392.jpeg)

1.  **Overview**

In this kit, there is a Keyestudio 8002b audio power amplifier. The main
components of this module are an adjustable potentiometer, a speaker,
and an audio amplifier chip;

The main function of this module is: it can amplify the output audio
signal, with a magnification of 8.5 times, and play sound or music
through the built-in low-power speaker, as an external amplifying device
for some music playing equipment.

In the experiment, we used the 8002b power amplifier speaker module to
emit sounds of various frequencies.

**2. Working Principle**

In fact, it is similar to a passive buzzer. The active buzzer has its
own oscillation source.Yet, the passive buzzer does not have internal
oscillation. When controlling the circuit, we need to input square waves
of different frequencies to the positive pole of the component and
ground the negative pole to control the buzzer to chime sounds of
different frequencies.

![](media/f5f372e0713df6439a7cc52f5caf1cad.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/afd2d5f63e3823e1cb941fc73a51d3ac.png" style="width:0.95556in;height:0.47986in" alt="8002b功放 喇叭模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio 8002b Audio Power Amplifier*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/c6e67388d17aae690f538a4c61f9fd9f.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin, PWM</p>
<p>from time import sleep</p>
<p>buzzer = PWM(Pin(15))</p>
<p>buzzer.duty(1000)</p>
<p>buzzer.freq(523)#DO</p>
<p>sleep(0.5)</p>
<p>buzzer.freq(586)#RE</p>
<p>sleep(0.5)</p>
<p>buzzer.freq(658)#MI</p>
<p>sleep(0.5)</p>
<p>buzzer.freq(697)#FA</p>
<p>sleep(0.5)</p>
<p>buzzer.freq(783)#SO</p>
<p>sleep(0.5)</p>
<p>buzzer.freq(879)#LA</p>
<p>sleep(0.5)</p>
<p>buzzer.freq(987)#SI</p>
<p>sleep(0.5)</p>
<p>buzzer.duty(0)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

1\. In this experiment, we use the PWM class of the machine module,
buzzer = PWM(Pin(15)) to create an instance of the PWM class, and the
buzzer pin is connected to GPIO15.

The buzzer.duty(1000): set the duty cycle, and the duty cycle is
1000/4095. The larger the value, the louder the buzzer. When set to 0,
the buzzer does not emit sound. **buzzer.freq()** is the frequency
setting method.

In the experiment, we use the PWM on the machine module. **buzzer =
PWM(Pin(15))**

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The power amplifier module will emit the
sound of the corresponding frequency corresponding to the beat :DO for
0.5s, Re for 0.5s, Mi for 0.5s, Fa for 0.5s, So for 0.5s, La 0.5s and Si
for 0.5s. Press “Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

### Project 18: 130 Motor

![](media/6c4e0d18c7c1867e27c0bac8e1c6412b.jpeg)

1.  **Description**

The 130 motor driver module is compatible with servo motors, which has
high efficiency and good quality fans.

It adopts a HR1124S motor control chip. HR1124S is a single-channel
H-bridge driver chip for DC motor solutions. In addition, this chip has
low standby current and low quiescent current.

The module is compatible with various single-chip control boards. In the
experiment, we can control the rotation direction of the motor by
outputting the voltage directions of the two signal terminals IN+ and
IN- to make the motor rotate.

**2. Working Principle**

The chip is used to help drive the motor. We can’t drive it with a
triode or an IO port due to its a large current of need. It is very
simple to make the motor rotate. Just apply voltage to both ends of the
motor. The direction of the motor is different in different voltage
directions. Within the rated voltage, the higher the voltage, the faster
the motor rotates; on the contrary, the lower the voltage, the slower
the motor rotates, or even unable to rotate.

So we can use the PWM port to control the speed of the motor. We haven't
learned PWM here, so we use the high and low levels to control the motor
first.

![](media/5ea2e4d2b18f87ffa9a31e834764ec4b.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6c2548137a8c675141b83227beeb2eb9.png" style="width:0.82917in;height:0.70694in" alt="KS6038 130电机驱动模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio 130 Motor*1</td>
<td>4P Dupont Wire*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b65d826ca481982fed0212dba2957c7c.jpeg" style="width:1.57361in;height:1.13611in" alt="123" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a815c48437199c6ab79d74cd2d583de0.png" style="width:0.44792in;height:2.0625in" /></td>
<td></td>
</tr>
<tr class="even">
<td>Micro USB Cable*1</td>
<td>6 AA Battery Holder*1</td>
<td>Battery (not included)*6</td>
<td></td>
</tr>
</tbody>
</table>

Note: the motor is separated with its fan, you need to assemble it
first.

**4. Connection Diagram**

<table>
<tbody>
<tr class="odd">
<td>130 Motor</td>
<td>ESP32 Expansion Board</td>
</tr>
<tr class="even">
<td>G</td>
<td>G</td>
</tr>
<tr class="odd">
<td>V</td>
<td>5V</td>
</tr>
<tr class="even">
<td>IN+</td>
<td>IO15</td>
</tr>
<tr class="odd">
<td>IN-</td>
<td>IO4</td>
</tr>
</tbody>
</table>

![](media/bbe7e2090eaae8cea355349c9484289b.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>#Two pins of the motor</p>
<p>INA = Pin(15, Pin.OUT) #INA corresponds to IN+</p>
<p>INB = Pin(4, Pin.OUT)#INB corresponds to IN-</p>
<p>while True:</p>
<p>#Counterclockwise 2s</p>
<p>INA.value(1)</p>
<p>INB.value(0)</p>
<p>time.sleep(2)</p>
<p>#stop 1s</p>
<p>INA.value(0)</p>
<p>INB.value(0)</p>
<p>time.sleep(1)</p>
<p>#Turn clockwise for 2s</p>
<p>INA.value(0)</p>
<p>INB.value(1)</p>
<p>time.sleep(2)</p>
<p>#stop 1s</p>
<p>INA.value(0)</p>
<p>INB.value(0)</p>
<p>time.sleep(1)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

Set pins to GPIO4, GPIO15, when the pin GPIO4 outputs low levels and the
pin GPIO15 outputs high levels, the motor will rotate counterclockwise;
when both pins are set to low, the motor stops rotating.

**7. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png). Turn the DIP switch
to ON , after powering on, click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current
script”, the code starts executing. the fan will rotate counterclockwise
for 2 seconds, stop for 1 second; and rotate clockwise for 2 seconds and
stop for 1 second; cycle alternately. Press “Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

### Project 19: Potentiometer

![](media/fe92a4f36758bc236d94290478fe5eac.jpeg)

1.  **Overview**

The following we will introduce is the Keyestudio rotary potentiometer
which is an analog sensor.

The digital IO ports can read the voltage value between 0 and 3.3V and
the module only outputs high levels. However, the analog sensor can read
the voltage value through 16 ADC analog ports on the ESP32 board. In the
experiment, we will display the test results on the Shell.

**2. Working Principle**

![](media/a6ca9064a864e572984fdc41207eaaca.jpeg)

It uses a 10K adjustable resistor. We can change the resistance by
rotating the potentiometer. The signal S can detect the voltage
changes(0-3.3V) which are analog quantity.

**ADC：**The more bits an ADC has, the denser the partitioning of the
simulation, the higher the accuracy of the final conversion.

![](media/f6c45550f4adf8373d7f1d01daec2c64.png)

The conversion formula is as follows:

**DAC：**The higher the precision of DAC, the higher the precision of the
output voltage value.  

The conversion formula is as follows:  

**ADC on ESP32：**

The ESP32 has 16 pins that can be used to measure analog signals. GPIO
pin serial numbers and analog pin definitions are shown below:  

<table>
<tbody>
<tr class="odd">
<td>ADC number in ESP32</td>
<td>ESP32 GPIO number</td>
</tr>
<tr class="even">
<td>ADC0</td>
<td>GPIO 36</td>
</tr>
<tr class="odd">
<td>ADC3</td>
<td>GPIO 39</td>
</tr>
<tr class="even">
<td>ADC4</td>
<td>GPIO 32</td>
</tr>
<tr class="odd">
<td>ADC5</td>
<td>GPIO33</td>
</tr>
<tr class="even">
<td>ADC6</td>
<td>GPIO34</td>
</tr>
<tr class="odd">
<td>ADC7</td>
<td>GPIO 35</td>
</tr>
<tr class="even">
<td>ADC10</td>
<td>GPIO 4</td>
</tr>
<tr class="odd">
<td>ADC11</td>
<td>GPIO0</td>
</tr>
<tr class="even">
<td>ADC12</td>
<td>GPIO2</td>
</tr>
<tr class="odd">
<td>ADC13</td>
<td>GPIO15</td>
</tr>
<tr class="even">
<td>ADC14</td>
<td>GPIO13</td>
</tr>
<tr class="odd">
<td>ADC15</td>
<td>GPIO 12</td>
</tr>
<tr class="even">
<td>ADC16</td>
<td>GPIO 14</td>
</tr>
<tr class="odd">
<td>ADC17</td>
<td>GPIO27</td>
</tr>
<tr class="even">
<td>ADC18</td>
<td>GPIO25</td>
</tr>
<tr class="odd">
<td>ADC19</td>
<td>GPIO26</td>
</tr>
</tbody>
</table>

**DAC on ESP32：**

The ESP32 has two 8-bit digital-to-analog converters connected to GPIO25
and GPIO26 pins, which are immutable, as shown below :

<table>
<tbody>
<tr class="odd">
<td>Simulate pin number</td>
<td>GPIO number</td>
</tr>
<tr class="even">
<td>DAC1</td>
<td>GPIO25</td>
</tr>
<tr class="odd">
<td>DAC2</td>
<td>GPIO26</td>
</tr>
</tbody>
</table>

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/9d866a71104fb3cf1826c41c3c940ba8.png" style="width:0.65in;height:0.86667in" alt="旋转电位器传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Rotary Potentiometer*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/ce7b953cd508fd8f2f9aafb805fae1f6.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin, ADC and DAC modules.</p>
<p>from machine import ADC,Pin,DAC</p>
<p>import time</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p># Read ADC value once every 0.1seconds, convert ADC value to DAC value and output it,</p>
<p># and print these data to “Shell”.</p>
<p>try:</p>
<p>while True:</p>
<p>adcVal=adc.read()</p>
<p>dacVal=adcVal//16</p>
<p>voltage = adcVal / 4095.0 * 3.3</p>
<p>print("ADC Val:",adcVal,"DACVal:",dacVal,"Voltage:",voltage,"V")</p>
<p>time.sleep(0.1)</p>
<p>except:</p>
<p>pass</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

1\. In the experiment, add "From Machine import ADC" to the top of your
Python file every time you use the ACD module, the same goes for DAC
modules. 

2\. machine.ADC(pin):Create an ADC object associated with the given pin.
pin:：The available pins are
Pin(36)、Pin(39)、Pin(34）、Pin(35)、Pin(32)、Pin(33). DAC(pin):
Create an DAC object associated with the given pin. Pin：The available
pins are pin (25) 、pin (26).

3.ADC. Read():Read ADC value and return ADC value.  

4\.**ADC.atten(db)**: Set attenuation ration (that is, the full range
voltage, such as the voltage of 11db full range is 3.3V)

**db**：attenuation ratio

**ADC.ATTIN\_0DB** —full range of 1.2V

**ADC.ATTN\_2\_5\_DB** —full range of 1.5V

**ADC.ATTN\_6DB** —full range of 2.0 V

**ADC.ATTN\_11DB** —full range of 3.3V

**ADC.width(bit)**: Set data width.

**bit**：data bit

**ADC.WIDTH\_9BIT** —9 data width

**ADC.WIDTH\_10BIT** — 10 data width

**ADC.WIDTH\_11BIT** — 11 data width

**ADC.WIDTH\_12BIT** — 12 data width

**5. The read()method reads the** ADCvalue，rang is 0\~4095，the
**adc.read()** reads the ADC value input by the ADC(Pin(36)) Pin and
assigns it to a variable named adcVal.  

6\. DAC.write(value):Output the voltage value, the data rang : 0-255，the
corresponding output voltage is 0-3.3V.

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The "Shell" window prints and displays the
potentiometer ADC value, DAC value and voltage value.

Rotating the potentiometer handle, the ADC value, DAC value and voltage
value will change. Press“Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/65e6848785b8e09c731df4dd1f68a3a0.png)

### Project 20: Steam Sensor

![](media/0062e47b90828244595c1fb93c45f1d5.jpeg)

1.  **Description**

This is a DIY electronic building block water drop sensor. It is an
analog (digital) input module, also called rain, rain sensor. It can be
used to monitor various weather conditions, detect whether it is raining
and the amount of rain, convert it into digital signal (DO) and analog
signal (AO) output, and is widely used in Arduino robot kits, raindrops,
rain sensors, and can be used for various It can monitor various weather
conditions, and convert it into digital signal and AO output, and can
also be used for automobile automatic wiper system, intelligent lighting
system and intelligent sunroof system.

In the experiment, we input the sensor signal terminal (S terminal) to
the analog port of the ESP32 development board, sense the change of the
analog value, and display the corresponding analog value on the shell.

**2. Working Principle**

Its principle is to detect the amount of water through the exposed
printed parallel lines on the circuit board. The more water there is,
the more wires will be connected, and the conductive contact area
increases. The voltage output by pin 2 will gradually increase. The
larger the analog value detected by the signal terminal S is.

It can also detect steam in the air. Two position holes are used to
install on the other devices.

![](media/790270169035ee740b28c49c4b1dde47.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b64cdb5749df7d2b7dd3719216c7aff3.png" style="width:0.91458in;height:0.65417in" alt="KS6048 水滴水蒸气传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio DIY Steam Sensor *1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/c4eb7a1f583dc8b99775578cd7cd4674.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin, ADC and DAC modules.</p>
<p>from machine import ADC,Pin,DAC</p>
<p>import time</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p># Read ADC value once every 0.1seconds, convert ADC value to DAC value and output it,</p>
<p># and print these data to “Shell”.</p>
<p>try:</p>
<p>while True:</p>
<p>adcVal=adc.read()</p>
<p>dacVal=adcVal//16</p>
<p>voltage = adcVal / 4095.0 * 3.3</p>
<p>print("ADC Val:",adcVal,"DACVal:",dacVal,"Voltage:",voltage,"V")</p>
<p>time.sleep(0.1)</p>
<p>except:</p>
<p>pass</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The Shell will display ADC value, DAC value
and voltage value of the sensor. When a few drops of water are placed in
the sensor sensing area, the ADC value, DAC value and voltage value will
change. The more water volume, the greater the output voltage value ,
ADC value and the DAC value. Press“Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/65e6848785b8e09c731df4dd1f68a3a0.png)

### Project 21: Sound Sensor

![](media/c4d4961f71c7e91bae04507f72cb56eb.jpeg)

1.  **Overview**

In this kit, there is a Keyestudio DIY electronic block and a sound
sensor. In the experiment, we test the analog value corresponding to the
sound level in the current environment with it. The louder the sound,
the larger the ADC, DAC and the voltage value, and the “shell”window
will display the test results.

**2. Working Principle**

It uses a high-sensitive microphone component and an LM386 chip. We
build the circuit with the LM386 chip and amplify the sound through the
high-sensitive microphone. In addition, we can adjust the sound volume
by the potentiometer. Rotate it clockwise, the sound will get louder.

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6406b86b355b4986a8b2ec74f770c2ba.png" style="width:0.69236in;height:0.92292in" alt="声音传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.8875in;height:0.47569in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Sound Sensor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/7a5b741aba98560eddadc3b7788325d9.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin, ADC and DAC modules.</p>
<p>from machine import ADC,Pin,DAC</p>
<p>import time</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p># Read ADC value once every 0.1seconds, convert ADC value to DAC value and output it,</p>
<p># and print these data to “Shell”.</p>
<p>try:</p>
<p>while True:</p>
<p>adcVal=adc.read()</p>
<p>dacVal=adcVal//16</p>
<p>voltage = adcVal / 4095.0 * 3.3</p>
<p>print("ADC Val:",adcVal,"DACVal:",dacVal,"Voltage:",voltage,"V")</p>
<p>time.sleep(0.1)</p>
<p>except:</p>
<p>pass</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The "Shell" window will display the sound
sensor ADC value, DAC value and voltage value. Rotate the potentiometer
clockwise and speak at the MIC. Then you can see the analog value get
larger, as shown below. Press“Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/16c179e59bfbbb62544d74ce501f0aa2.png)

### Project 22: Photoresistor

![](media/37bb57bcf72ba62056bbc61164185f0a.png)

1.  **Description**

In this kit, there is a photoresistor which consists of photosensitive
resistance elements. Its resistance changes with the light intensity.
Also, it converts the resistance change into a voltage change through
the characteristic of the photosensitive resistive element. When wiring
it up, we interface its signal terminal (S terminal) with the analog
port of ESP32 , so as to sense the change of the analog value, and
display the corresponding analog value in the shell.

**2. Working Principle**

If there is no light, the resistance is 0.2MΩ and the detected voltage
at the terminal 2 is close to 0. When the light intensity increases, the
resistance of photoresistor and detected voltage will diminish.

![](media/651e70e24ecca152ec701deb7a6ea102.png)

**3. Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/21847f439e9532462a71d11921112a66.png" style="width:0.62292in;height:0.83056in" alt="光敏电阻传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio DIY Photoresistor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/0b880c099cb70864881c501c9a3a8dbb.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin, ADC and DAC modules.</p>
<p>from machine import ADC,Pin,DAC</p>
<p>import time</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p># Read ADC value once every 0.1seconds, convert ADC value to DAC value and output it,</p>
<p># and print these data to “Shell”.</p>
<p>try:</p>
<p>while True:</p>
<p>adcVal=adc.read()</p>
<p>dacVal=adcVal//16</p>
<p>voltage = adcVal / 4095.0 * 3.3</p>
<p>print("ADC Val:",adcVal,"DACVal:",dacVal,"Voltage:",voltage,"V")</p>
<p>time.sleep(0.1)</p>
<p>except:</p>
<p>pass</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The "Shell" window will display the
photoresistor ADC value, DAC value and voltage value. The brighter the
light, the greater the analog value, as shown below. Press“Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/3b141ec51733d34caff4f0b2afc653a4.png)

### Project 23: NTC-MF52AT Thermistor

![](media/868d93395d983645baab872091991403.jpeg)

1.  **Overview**

In the experiment, there is a NTC-MF52AT analog thermistor. We connect
its signal terminal to the analog port of the ESP32 mainboard and read
the corresponding ADC value, voltage value and thermistor value.

We can use analog values to calculate the temperature of the current
environment through specific formulas. Since the temperature calculation
formula is more complicated, we only read the corresponding analog
value.

**2. Working Principle**

![](media/84a67bb2b90b4740c09d914dc6402f48.png)

NTC-MF52AT thermistor elements. The NTC-MF52AT thermistor element can
sense the changes of the surrounding environment temperature. Resistance
changes with the temperature, causing the voltage of the signal terminal
S to change.

This sensor uses the characteristics of NTC-MF52AT thermistor element to
convert resistance changes into voltage changes.

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/481d8a887573a4aeeb9a61a8f5b1fe6f.png" style="width:0.64236in;height:0.93889in" alt="模拟温度传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio NTC-MF52AT Thermistor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/7fba5e360e5bcc3e60ef27a77b3362d1.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin, ADC</p>
<p>import time</p>
<p>import math</p>
<p>#Set ADC</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p>try:</p>
<p>while True:</p>
<p>adcValue = adc.read()</p>
<p>voltage = adcValue / 4095 * 3.3</p>
<p>Rt = 10 * voltage / (3.3-voltage)</p>
<p>tempK = (1 / (1 / (273.15+25) + (math.log(Rt/4.7)) / 3950))</p>
<p>tempC = (tempK - 273.15)</p>
<p>print("ADC value:",adcValue," Voltage:",voltage,"V"," Temperature: ",tempC,"C");</p>
<p>time.sleep(1)</p>
<p>except:</p>
<p>pass</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The "Shell" window will display the
thermistor ADC value, voltage value and temperature value, as shown
below. Press“Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

![](media/77f18a9e099306cd7111d6b2df2b5eb6.png)

### Project 24: Thin-film Pressure Sensor

![](media/a9ae2963fc87b3502703f7dd5eb208ec.jpeg)

1.  **Overview**

In this kit, there is a Keyestudio thin-film pressure sensor. The
thin-film pressure sensor composed of a new type of Nano
pressure-sensitive material and a comfortable ultra-thin film substrate,
has waterproof and pressure-sensitive functions.

In the experiment, we determine the pressure by collecting the analog
signal on the S end of the module. The smaller the ADC value, DAC value
and voltage value, the greater the pressure; and the displayed results
will shown on the Shell.

![](media/520fa537602873d2a337731318668348.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/84d460c90f09b3f3baa5819ab8655e87.png" style="width:0.375in;height:1.21042in" alt="薄膜压力传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Thin-film Pressure Sensor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/a461b6b0227b4430b64da6e80be8d898.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin, ADC and DAC modules.</p>
<p>from machine import ADC,Pin,DAC</p>
<p>import time</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p># Read ADC value once every 0.1seconds, convert ADC value to DAC value and output it,</p>
<p># and print these data to “Shell”.</p>
<p>try:</p>
<p>while True:</p>
<p>adcVal=adc.read()</p>
<p>dacVal=adcVal//16</p>
<p>voltage = adcVal / 4095.0 * 3.3</p>
<p>print("ADC Val:",adcVal,"DACVal:",dacVal,"Voltage:",voltage,"V")</p>
<p>time.sleep(0.1)</p>
<p>except:</p>
<p>pass</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The "Shell" window will display the Thin-film
Pressure Sensor ADC value, voltage value and DAC value. When the
thin-film is pressed by fingers, the analog value will decrease, as
shown below. Press “Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend” to exit the program.

![](media/e43fa7aaed34eea4fee5a535699ddf3f.png)

### Project 25: Flame Sensor

![](media/c6c3bf0c9bf0af22a2aa06c5b7399cfd.jpeg)

1.  **Description**

In daily life, it is often seen that a fire broke out without any
precaution. It will cause great economic and human loss. So how can we
avoid this situation? Right, install a flame sensor and a speaker in
those places that easily break out a fire. When the flame sensor detects
a fire, the speaker will alarm people quickly to put out the fire.

So in this project, you will learn how to use a flame sensor and an
active buzzer module to simulate the fire alarm system.

**2. Working Principle**

This flame sensor can be used to detect fire or other light sources with
wavelength stands at 700nm \~ 1000nm. Its detection angle is about 60°.
You can rotate the potentiometer on the sensor to control its
sensitivity. Adjust the potentiometer to make the LED at the critical
point between on and off state. The sensitivity is the best.

From the below figure, power up. When detecting fire, the digital pin
outputs low levels, the red LED2 will light up first, the digital signal
terminal D0 outputs a low level, and the red LED1 will light up. The
stronger the external infrared light, the smaller the value; the weaker
the infrared light, the larger the value.

![](media/01f69822915149445858a471784ebddf.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/4ecedf84c69e9264059ffd14b02592bd.png" style="width:0.95278in;height:0.57153in" alt="火焰传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>keyestudio Flame Sensor*1</td>
<td>4P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/1f2a3bd0f40c2c14162e1c148044ab22.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin, ADC and DAC modules.</p>
<p>from machine import ADC,Pin,DAC</p>
<p>import time</p>
<p>flame_D = Pin(13, Pin.IN)</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p># Read digital value and ADC value once every 0.1seconds, convert ADC value to DAC value and Voltage value and output it,</p>
<p># and print these data to “Shell”.</p>
<p>try:</p>
<p>while True:</p>
<p>digitalVal = flame_D.value()</p>
<p>adcVal=adc.read()</p>
<p>dacVal=adcVal//16</p>
<p>voltage = adcVal / 4095.0 * 3.3</p>
<p>print("digitalVal:",digitalVal,"ADC Val:",adcVal,"DACVal:",dacVal,"Voltage:",voltage,"V")</p>
<p>time.sleep(0.1)</p>
<p>except:</p>
<p>pass</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

Two pins we use are defined as GPIO13 and GPIO34 according to the
wiring-up diagram, and print digital signals and analog signals
respectively.

**7. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. After powering on, rotating the potentiometer
on the sensor, we can adjust the red LED bright and not bright critical
point. The red LED2 on the sensor module is lit, while the red LED1 is
not. The Shell will print and display the digital value, ADC value, DAC
value and voltage value of the flame sensor. When fire is detected, the
LED1 will be on. the digital value will change from 1 to 0, and the
analog value will become smaller, as shown below. Press “Ctrl+C”or click
![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend” to exit the program.

![](media/fd9e95873daf5dc47c1368970f1bc6dd.png)

### Project 26: MQ-2 Gas Sensor

![](media/f712788d3997805df25abe4a99d42461.GIF)

1.  **Description**

This analog gas sensor - MQ2 is used in gas leakage detecting equipment
in consumer electronics and industrial markets.

This sensor is suitable for detecting LPG, I-butane, propane, methane,
alcohol, Hydrogen and smoke. It has high sensitivity and quick response.

In addition, the sensitivity can be adjusted by rotating the
potentiometer.

In the experiment, we read the analog value at the A0 port and the D0
port to determine the content of gas.

**2. Working Principle**

The greater the concentration of smoke, the greater the conductivity,
the lower the output resistance, the greater the output analog signal.

When in use, the A0 terminal reads the analog value of the corresponding
gas; the D0 terminal is connected to an LM393 chip (voltage comparator),
we can adjust the alarm threshold of the measured gas through the
potentiometer, and output the digital value at D0. When the measured gas
content exceeds the critical point, the D0 terminal outputs a low level;
when the measured gas content does not exceed the critical point, the D0
terminal outputs a high level.

![](media/c55edbe71237172f6b80877504a9debb.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/ee4483f37a6f3609acdb661095f4b706.png" style="width:1.04167in;height:0.52708in" alt="KS6029 MQ-2 模拟气体传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>keyestudio DIY Analog Gas Sensor*1</td>
<td>4P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/9421fdc1d7de9566b377f1bcd9e060a8.png)

**5. Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin, ADC and DAC modules.</p>
<p>from machine import ADC,Pin,DAC</p>
<p>import time</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>mq2_D = Pin(13, Pin.IN)</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p># Read digital value and ADC value once every 0.1seconds, convert ADC value to DAC value and Voltage value and output it,</p>
<p># and print these data to “Shell”.</p>
<p>while True:</p>
<p>digitalVal = mq2_D.value()</p>
<p>adcVal=adc.read()</p>
<p>dacVal=adcVal//16</p>
<p>voltage = adcVal / 4095.0 * 3.3</p>
<p>print("digitalVal:",digitalVal,"ADC Val:",adcVal,"DACVal:",dacVal,"Voltage:",voltage,"V", end = " ")</p>
<p>if digitalVal == 0:</p>
<p>print("Exceeding")</p>
<p>else:</p>
<p>print("Normal")</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing.The shell will display the corresponding data
and string. After powering on, by rotating the potentiometer on the
sensor, we can adjust the red LED bright and not bright critical point.
When the sensor detects the smoke or combustible gas, the red LED lights
up and the digital value in the Shell changes from 1 to 0, the ADC
value, DAC value and voltage value increase, as shown below. Press
“Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend” to exit
the program.

![](media/31762387bb2e31de727ea9ece9c86cec.png)

### Project 27: Joystick Module

![](media/a28a09d0d9103cc8b93f2ae71f98482a.jpeg)

**1. Overview**

Game handle controllers are ubiquitous.

It mainly uses PS2 joysticks. When controlling it, we need to connect
the X and Y ports of the module to the analog port of the single-chip
microcomputer, port B to the digital port of the single-chip
microcomputer, VCC to the power output port(3.3-5V), and GND to the GND
of the MCU. We can read the high and low levels of two analog values and
one digital port) to determine the working status of the joystick on the
module.

In the experiment, two analog values(x axis and y axis) will be shown on
Shell.

**2. Working Principle**

![](media/efcb8ed421ab3572af890d73788a8c01.jpeg)

In fact, its working principle is very simple. Its inside structure is
equivalent to two adjustable potentiometers and a button. When this
button is not pressed and the module is pulled down by R1, low levels
will be output ; on the contrary, when the button is pressed, VCC will
be connected (high levels), When we move the joystick, the internal
potentiometer will adjust to output different voltages, and we can read
the analog value.

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/1f5bf5d8d48c675b98dd2cbfca6c31b7.png" style="width:1.08819in;height:0.53681in" alt="摇杆模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/fc3fd9c0110b04d1af77a2ff8c01a10a.png" style="width:0.95208in;height:0.39931in" alt="5p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Joystick Module*1</td>
<td>5P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/c1838e7013bc930e997d7684229bcea3.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin, ADC</p>
<p>import time</p>
<p># Initialize the joystick module (ADC function)</p>
<p>rocker_x=ADC(Pin(34))</p>
<p>rocker_y=ADC(Pin(35))</p>
<p>button_z=Pin(13,Pin.IN,Pin.PULL_UP)</p>
<p># Set the acquisition range of voltage of the two ADC channels to 0-3.3V,</p>
<p># and the acquisition width of data to 0-4095.</p>
<p>rocker_x.atten(ADC.ATTN_11DB)</p>
<p>rocker_y.atten(ADC.ATTN_11DB)</p>
<p>rocker_x.width(ADC.WIDTH_12BIT)</p>
<p>rocker_y.width(ADC.WIDTH_12BIT)</p>
<p># In the code, configure Z_Pin to pull-up input mode.</p>
<p># In loop(), use Read () to read the value of axes X and Y</p>
<p># and use value() to read the value of axis Z, and then display them.</p>
<p>while True:</p>
<p>print("X,Y,Z:",rocker_x.read(),",",rocker_y.read(),",",button_z.value())</p>
<p>time.sleep(0.5)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

In the experiment, according to the wiring diagram, the x pin is set to
GPIO34, the y pin is set to GPIO35 and the pin of the joystick is set to
GPIO13.

**7. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The "Shell" window will print the analog and
digital values of the current joystick. Moving the joystick will change
the analog and digital values in "Shell". Press“Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/06a9de681779df5cfc7e6bc24a928a3a.jpeg)

![](media/6e7dd18099836222c5237c9e0e659539.png)

### Project 28: Relay Module

1.  **Overview**

In our daily life, we usually use communication to drive electrical
equipments, and sometimes we use switches to control electrical
equipments. If the switch is connected directly to the ac circuit,
leakage occurs and people are in danger. Therefore, from the perspective
of safety, we specially designed this relay module with NO(normally
open) end and NC(normally closed) end.  

**2. Working Principle**

Relay is compatible with a variety of microcontroller control board,
such as Arduino series microcontroller, which is a small current to
control the operation of large current "automatic switch".  

Input Voltage：3.3V-5V

![](media/be1c90d2b52fc2489590e3f702a087bf.emf)

It can let the MCU control board drive 3A load, such as an LED lamp
belt, a DC motor, a micro water pump and a solenoid valve plugable
interface design, which is easy to use.  

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/1ea87894c6aa8d475203e447ad5e930a.png" style="width:1.27083in;height:0.68056in" alt="8" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Relay Module*1</td>
<td>3P Dupont Wire*2</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/b70c5d14c6a3d8820881af0bf8988848.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p># create relay from Pin 15, Set Pin 15 to output</p>
<p>relay = Pin(15, Pin.OUT)</p>
<p># The relay is opened, COM and NO are connected on the relay, and COM and NC are disconnected.</p>
<p>def relay_on():</p>
<p>relay(1)</p>
<p># The relay is closed, the COM and NO on the relay are disconnected, and the COM and NC are connected.</p>
<p>def relay_off():</p>
<p>relay(0)</p>
<p># Loop, the relay is on for one second and off for one second</p>
<p>while True:</p>
<p>relay_on()</p>
<p>time.sleep(1)</p>
<p>relay_off()</p>
<p>time.sleep(1)</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The relay will cycle on and off, on for 1
second, off for 1 second. At the same time, you can hear the sound of
the relay on and off as well as see the change of the indicator light on
the relay. Press“Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

### Project 29: SK6812 RGB Module

![](media/effda831f7c06cea2c443d8352f1a693.jpeg)

1.  **Overview**

In previous lessons, we learned about the plug-in RGB module and used
PWM signals to color the three pins of the module.

There is a Keyestudio 6812 RGB module whose the driving principle is
different from the plug-in RGB module. It can only control with one pin.
This is a set. It is an intelligent externally controlled LED light
source with the control circuit and the light-emitting circuit. Each LED
element is the same as a 5050 LED lamp bead, and each component is a
pixel. There are four lamp beads on the module, which indicates four
pixels.

In the experiment, we make different lights show different colors.

**2. Working Principle**

From the schematic diagram, we can see that these four pixel lighting
beads are all connected in series. In fact, no matter how many they are,
we can use a pin to control a light and let it display any color. The
pixel point contains a data latch signal shaping amplifier drive
circuit, a high-precision internal oscillator and a 12V high-voltage
programmable constant current control part, which effectively ensures
the color of the pixel point light is highly consistent.

The data protocol adopts a single-wire zero-code communication method.
After the pixel is powered up and reset, the S terminal receives the
data transmitted from the controller. The first 24bit data sent is
extracted by the first pixel and sent to the data latch of the pixel.

![](media/f0d824a10a88aa0fbabfb685634672fc.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/42e093202e7233aaaa42b9ac64f51d98.png" style="width:0.66111in;height:0.875in" alt="6812 RGB模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio 6812 RGB Module*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/c24ec4320937c7115802a2937180f703.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>#Import Pin, neopiexl and time modules.</p>
<p>from machine import Pin</p>
<p>import neopixel</p>
<p>import time</p>
<p>#Define the number of pin and LEDs connected to neopixel.</p>
<p>pin = Pin(15, Pin.OUT)</p>
<p>np = neopixel.NeoPixel(pin, 4)</p>
<p>#brightness :0-255</p>
<p>brightness=100</p>
<p>colors=[[brightness,0,0], #red</p>
<p>[0,brightness,0], #green</p>
<p>[0,0,brightness], #blue</p>
<p>[brightness,brightness,brightness], #white</p>
<p>[0,0,0]] #close</p>
<p>#Nest two for loops to make the module repeatedly display five states of red, green, blue, white and OFF.</p>
<p>while True:</p>
<p>for i in range(0,5):</p>
<p>for j in range(0,4):</p>
<p>np[j]=colors[i]</p>
<p>np.write()</p>
<p>time.sleep_ms(50)</p>
<p>time.sleep_ms(500)</p>
<p>time.sleep_ms(500)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

A few function ports and functions:

**np = neopixel.NeoPixel(pin, 4)** , there are four LED beads, so we set
to 4.

**pin = Pin(15, Pin.OUT)** , this is the pin number, we connect to GP15.

**brightness = 100**, brightness setting 255 implies brightest.

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. Then we can see the four RGB LEDs show red,
green, blue and white color; as shown below;

Press “Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to
exit the program.

### Project 30: Rotary Encoder

![](media/ec37b336b8f5620b62b04224b132840a.jpeg)

1.  **Overview**

In this kit, there is a Keyestudio rotary encoder, dubbed as switch
encoder. It is applied to automotive electronics, multimedia audio,
instrumentation, household appliances, smart home, medical equipment and
so on.

In the experiment, it it used for counting. When we rotate the rotary
encoder clockwise, the set data falls by 1; if you rotate it
anticlockwise, the set data is up 1; and when the middle button is
pressed, the value will be show on Shell.

**2. Working Principle**

The incremental encoder converts the displacement into a periodic electric signal, and then converts this signal into a counting pulse, and the number of pulses indicates the size of the displacement.This module mainly uses 20-pulse rotary encoder components. It can calculate the number of pulses output during clockwise and reverse rotation. There is no limit to count rotation. It resets to the initial state, that is, starts counting from 0.           

![](media/2fb56ec6fa69e66fcca4243617d4b18c.jpeg)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/989ee8ccd2a016dcaeb0bef68d55e912.png" style="width:0.97778in;height:0.73333in" alt="旋转编码器模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/fc3fd9c0110b04d1af77a2ff8c01a10a.png" style="width:0.95208in;height:0.39931in" alt="5p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.94722in;height:0.41875in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Rotary Encoder*1</td>
<td>5P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/add429af09e0e3d449fba9b17b3d0af4.png)

**5.Add Library：**

Open“Thonny”, click“This computer”→“D:”→“2.
ESP32\_code\_MicroPython”→“lesson 30. Rotary encoder counting”.
Choose“rotary.py”and“rotary\_irq\_rp2.py”，right-click“Upload to /”.

![](media/85ed8ab5ae74f3c651b168971cf7c2ba.png)

![](media/fdc65c590bf0b0e81d42f6b8032219c5.png)

4.  **Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>import time</p>
<p>from rotary_irq_rp2 import RotaryIRQ</p>
<p>from machine import Pin</p>
<p>SW=Pin(27,Pin.IN,Pin.PULL_UP)</p>
<p>r = RotaryIRQ(pin_num_clk=12,</p>
<p>pin_num_dt=14,</p>
<p>min_val=0,</p>
<p>reverse=False,</p>
<p>range_mode=RotaryIRQ.RANGE_UNBOUNDED)</p>
<p>val_old = r.value()</p>
<p>while True:</p>
<p>try:</p>
<p>val_new = r.value()</p>
<p>if SW.value()==0 and n==0:</p>
<p>print("Button Pressed")</p>
<p>print("Selected Number is : ",val_new)</p>
<p>n=1</p>
<p>while SW.value()==0:</p>
<p>continue</p>
<p>n=0</p>
<p>if val_old != val_new:</p>
<p>val_old = val_new</p>
<p>print('result =', val_new)</p>
<p>time.sleep_ms(50)</p>
<p>except KeyboardInterrupt:</p>
<p>break</p></td>
</tr>
</tbody>
</table>

**7. Code Explanation**

1.  We will see the file rotary.py and rotary\_irq\_rp2.py. This means
    that we save them in the ESP32 successfully. Then we can use **from
    rotary\_irq\_rp2 import RotaryIRQ.**

2.  **SW=Pin(20,Pin.IN,Pin.PULL\_UP)** indicates that the SW pin is
    connected to GPIO27, **pin\_num\_clk=12** indicates that the pin CLK
    is connected to GPIO12, and **pin\_num\_dt=14** means that the DT
    pin is connected to GPIO14. We can change these pin numbers.

3.  **try/except** is the python language exception capture processing
    statement, **try** executes the code, **except** executes the code
    when an exception occurs, and when we press Ctrl+C, the program
    exits.

4.  **r.value()** returns the value of the encoder

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. Rotate the encoder clockwise, the displayed
data decrease; rotate the encoder counterclockwise, the displayed data
increase; press the middle button of the encoder, the displayed data is
the value of the encoder, as shown in the figure below. Press“Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/ea0e88b6a555f4dff831966f20c89782.png)

### Project 31: Servo Control

![](media/165f16e47a832fc4dcaea6e4a1c11194.jpeg)

1.  **Overview**

Servo motor is a position control rotary actuator. It mainly consists of
a housing, a circuit board, a core-less motor, a gear and a position
sensor. Its working principle is that the servo receives the signal sent
by MCU or receiver and produces a reference signal with a period of 20ms
and width of 1.5ms, then compares the acquired DC bias voltage to the
voltage of the potentiometer and obtain the voltage difference output.

In general, servo has three lines in brown, red and orange. The brown
wire is grounded, the red one is a positive pole line and the orange one
is a signal line.

![](media/4b15604cd8a82aeb39497c7544b39f93.emf)

![](media/3366fe332bcf286659f9bf21a8cf880f.png)

**2. Working Principle**

When the motor speed is constant, the potentiometer is driven to rotate
through the cascade reduction gear, which leads that the voltage
difference is 0, and the motor stops rotating. Generally, the angle
range of servo rotation is 0° --180 °

The rotation angle of servo motor is controlled by regulating the duty
cycle of PWM (Pulse-Width Modulation) signal. The standard cycle of PWM
signal is 20ms (50Hz). Theoretically, the width is distributed
between 1ms-2ms, but in fact, it's between 0.5ms-2.5ms. The width
corresponds the rotation angle from 0° to 180°. But note that for
different brand motors, the same signal may have different rotation
angles. 

![](media/b4993212773e13b1a4424b3d7ef41ab6.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b9a96e60ed3aee985db5d4dcaf9bf38b.png" style="width:1.05833in;height:1.05069in" alt="舵机" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Servo*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/53dbdf43b364542bedb39e45132a2af9.png)

**5.Test Code1：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin, PWM</p>
<p>import time</p>
<p>pwm = PWM(Pin(4))</p>
<p>pwm.freq(50)</p>
<p>'''</p>
<p>Duty cycle corresponding to the Angle</p>
<p>0°----2.5%----25</p>
<p>45°----5%----51.2</p>
<p>90°----7.5%----77</p>
<p>135°----10%----102.4</p>
<p>180°----12.5%----128</p>
<p>'''</p>
<p>angle_0 = 25</p>
<p>angle_90 = 77</p>
<p>angle_180 = 128</p>
<p>while True:</p>
<p>pwm.duty(angle_0)</p>
<p>time.sleep(1)</p>
<p>pwm.duty(angle_90)</p>
<p>time.sleep(1)</p>
<p>pwm.duty(angle_180)</p>
<p>time.sleep(1)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation 1**

According to the angle of the signal pulse width, it is converted into a
duty cycle. The formula is: 2.5+angle/180\*10. The PWM pin resolution of
ESP32 is 2^10 = 1024. When converted to 0 degree, its duty cycle is 1024
\* 2.5% = 25.6 , when the angle is 180 degrees, its duty cycle value is
1024\* 12.5% = 128, these two values will be related to the program,
considering the error and rotation angle, I set the duty cycle at
between 10 and 150, the servo can rotate smoothly 0\~180 degrees

**7. Test Result 1：**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. the servo will rotate 0°，90° and 180°
cyclically. Press “Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend” to exit the program.

**8.Test Code2：**

<table>
<tbody>
<tr class="odd">
<td><p>from utime import sleep</p>
<p>from machine import Pin</p>
<p>from machine import PWM</p>
<p>pwm = PWM(Pin(4))#Steering gear pin is connected to GP4.</p>
<p>pwm.freq(50)#20ms period, so the frequency is 50Hz</p>
<p>'''</p>
<p>Duty cycle corresponding to the Angle</p>
<p>0°----2.5%----25</p>
<p>45°----5%----51.2</p>
<p>90°----7.5%----77</p>
<p>135°----10%----102.4</p>
<p>180°----12.5%----128</p>
<p>'''</p>
<p># Set the servo motor rotation Angle</p>
<p>def setServoCycle (position):</p>
<p>pwm.duty(position)</p>
<p>sleep(0.01)</p>
<p># Convert the rotation Angle to duty cycle</p>
<p>def convert(x, i_m, i_M, o_m, o_M):</p>
<p>return max(min(o_M, (x - i_m) * (o_M - o_m) // (i_M - i_m) + o_m), o_m)</p>
<p>while True:</p>
<p>for degree in range(0, 180, 1):#servo goes from 0 to 180</p>
<p>pos = convert(degree, 0, 180, 20, 150)</p>
<p>setServoCycle(pos)</p>
<p>for degree in range(180, 0, -1):#servo goes from 180 to 0</p>
<p>pos = convert(degree, 0, 180, 20, 150)</p>
<p>setServoCycle(pos)</p></td>
</tr>
</tbody>
</table>

**9. Code Explanation 2**

**convert(x, i\_m, i\_M, o\_m, o\_M)**: x is the value we want to map;
**i\_m, i\_M** are the lower and upper limits of the current value;
o\_m, o\_M are the lower and upper limits of the target range we want to
map to.

**10. Test Result 2**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The servo rotates from 0° to 180° by moving
1° for each 15ms. Press “Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

### Project 32: Ultrasonic Sensor

![](media/8f99fc89502d1ae2543839b4950da5b6.jpeg)

Bats and some marine animals are able to use high frequencies of sound
for echolocation or communication. They can emit ultrasonic waves from
the larynx through the mouth or nose and use the sound waves that bounce
back to orient and determine the position, size and whether nearby
objects are moving. Ultrasonic is a frequency higher than 20000 Hz sound
wave, which has a good direction, a strong penetration ability, and is
easy to obtain more concentrated sound energy as well as spread far in
the water. It can be used for ranging, speed measurement, cleaning,
welding, gravel, sterilization and disinfection. What‘s more, it has
many applications in medicine, military, industry and agriculture.

1.  **Overview**

In this kit, there is a keyes HC-SR04 ultrasonic sensor, which can
detect obstacles in front and the detailed distance between the sensor
and the obstacle. Its principle is the same as that of bat flying. It
can emit the ultrasonic signals that cannot be heard by humans. When
these signals hit an obstacle and come back immediately. The distance
between the sensor and the obstacle can be calculated by the time gap of
emitting signals and receiving signals.

In the experiment, we use the sensor to detect the distance between the
sensor and the obstacle, and print the test result.

**2. Working Principle**

The most common ultrasonic ranging method is the echo detection. As
shown below; when the ultrasonic emitter emits the ultrasonic waves
towards certain direction, the counter will count. The ultrasonic waves
travel and reflect back once encountering the obstacle. Then the counter
will stop counting when the receiver receives the ultrasonic waves
coming back.

The ultrasonic wave is also sound wave, and its speed of sound V is
related to temperature. Generally, it travels 340m/s in the air.
According to time t, we can calculate the distance s from the emitting
spot to the obstacle.

s=340t/2.

The HC-SR04 ultrasonic ranging module can provide a non-contact distance
sensing function of 2cm-400cm, and the ranging accuracy can reach as
high as 3mm; the module includes an ultrasonic transmitter, receiver and
control circuit. Basic working principle:

1\. First pull down the TRIG, and then trigger it with at least 10us
high level signal;

2\. After triggering, the module will automatically transmit eight 40KHZ
square waves, and automatically detect whether there is a signal to
return.

3\. If there is a signal returned back, through the ECHO to output a
high level, the duration time of high level is actually the time from
emission to reception of ultrasonic.

![](media/686176f637ba288e3b20d63bb1054477.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/1a1dc36771654248ade08b9d9f115f57.png" style="width:0.92292in;height:0.50903in" alt="超声波模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio SR01 Ultrasonic Sensor*1</td>
<td>4P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram:**

![](media/07eb56920ed1cb9b55deab51b7c61d8d.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p># Define the control pins of the ultrasonic ranging module.</p>
<p>Trig = Pin(13, Pin.OUT, 0)</p>
<p>Echo = Pin(14, Pin.IN, 0)</p>
<p>distance = 0 # Define the initial distance to be 0.</p>
<p>soundVelocity = 340 #Set the speed of sound.</p>
<p># The getDistance() function is used to drive the ultrasonic module to measure distance,</p>
<p># the Trig pin keeps at high level for 10us to start the ultrasonic module.</p>
<p># Echo.value() is used to read the status of ultrasonic module’s Echo pin,</p>
<p># and then use timestamp function of the time module to calculate the duration of Echo</p>
<p># pin’s high level,calculate the measured distance based on time and return the value.</p>
<p>def getDistance():</p>
<p>Trig.value(1)</p>
<p>time.sleep_us(10)</p>
<p>Trig.value(0)</p>
<p>while not Echo.value():</p>
<p>pass</p>
<p>pingStart = time.ticks_us()</p>
<p>while Echo.value():</p>
<p>pass</p>
<p>pingStop = time.ticks_us()</p>
<p>pingTime = time.ticks_diff(pingStop, pingStart) // 2</p>
<p>distance = int(soundVelocity * pingTime // 10000)</p>
<p>return distance</p>
<p># Delay for 2 seconds and wait for the ultrasonic module to stabilize,</p>
<p># Print data obtained from ultrasonic module every 500 milliseconds.</p>
<p>time.sleep(2)</p>
<p>while True:</p>
<p>time.sleep_ms(500)</p>
<p>distance = getDistance()</p>
<p>print("Distance: ", distance, "cm")</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The "Shell" window will print the distance
between the ultrasonic sensor and the object. Press“Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/ce873cf513307a15f9aa58078c8dd7d6.png)

### Project 33: IR Receiver Module

![](media/80e8f8d8ddc35df9425032ec4ef783ee.png)

1.  **Overview**

There is no doubt that infrared remote control is ubiquitous in daily
life. It is used to control various household appliances, such as TVs,
stereos, video recorders and satellite signal receivers. Infrared remote
control is composed of infrared transmitting and infrared receiving
systems, that is, an infrared remote control and infrared receiving
module and a single-chip microcomputer capable of decoding.

​    

In this experiment, we need to know how to use the infrared receiving
sensor, whichr mainly uses the VS1838B infrared receiving sensor
element. It integrates receiving, amplifying, and demodulating. The
internal IC has already completed the demodulation, and the output is a
digital signal. It can receive 38KHz modulated remote control signal. In
the experiment, we use the IR receiver to receive the infrared signal
emitted by the external infrared transmitting device, and display the
received signal in the shell.

**2. Working Principle**

The main part of the IR remote control system is modulation,
transmission and reception. The modulated carrier frequency is generally
between 30khz and 60khz, and most of them use a square wave of 38kHz and
a duty ratio of 1/3. A 4.7K pull-up resistor R3 is added to the signal
end of the infrared receiver.

![](media/845973091e7fe407e7fa0e96fc1cf4f1.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/06218167222e41c71cdcec1c9dc08982.png" style="width:0.64444in;height:0.85139in" alt="红外接收模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.97778in;height:0.52431in" alt="USB线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/10ccf14d80feba64bba0c1eacd02b09d.png" style="width:0.87986in;height:0.425in" alt="遥控器" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio IR Receiver*1</td>
<td>3P Dupont Wire*1</td>
<td>MicroUSB线*1</td>
<td>Remote Control*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/f54763e2701fefc503f275dcb9410ad0.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>import utime</p>
<p>from machine import Pin</p>
<p>ird = Pin(15,Pin.IN)</p>
<p>act = </p>
<p>def read_ircode(ird):</p>
<p>wait = 1</p>
<p>complete = 0</p>
<p>seq0 = []</p>
<p>seq1 = []</p>
<p>while wait == 1:</p>
<p>if ird.value() == 0:</p>
<p>wait = 0</p>
<p>while wait == 0 and complete == 0:</p>
<p>start = utime.ticks_us()</p>
<p>while ird.value() == 0:</p>
<p>ms1 = utime.ticks_us()</p>
<p>diff = utime.ticks_diff(ms1,start)</p>
<p>seq0.append(diff)</p>
<p>while ird.value() == 1 and complete == 0:</p>
<p>ms2 = utime.ticks_us()</p>
<p>diff = utime.ticks_diff(ms2,ms1)</p>
<p>if diff &gt; 10000:</p>
<p>complete = 1</p>
<p>seq1.append(diff)</p>
<p>code = ""</p>
<p>for val in seq1:</p>
<p>if val &lt; 2000:</p>
<p>if val &lt; 700:</p>
<p>code += "L"</p>
<p>else:</p>
<p>code += "H"</p>
<p># print(code)</p>
<p>command = ""</p>
<p>for k,v in act.items():</p>
<p>if code == v:</p>
<p>command = k</p>
<p>if command == "":</p>
<p>command = code</p>
<p>return command</p>
<p>while True:</p>
<p>command = read_ircode(ird)</p>
<p>print(command)</p>
<p>utime.sleep(0.5)</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. Find the infrared remote control, pull out
the insulating sheet, and press the button at the receiving head of the
infrared receiving sensor. After receiving signals, the LED on the
infrared receiving sensor also starts to flash, as shown in the figure
below. Press“Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

![](media/ff10b0aac375db3c7ad55db88a876026.png)

### Project 34: DS18B20 Temperature Sensor

![](media/29c66f83d6ea8bbc378b0508e78d5f3b.png)

1.  **Description**

In this kit, there is a DS18B20 temperature sensor, which is from maxim.
The MCU can communicate with the DS18B20 through 1-Wire protocol, and
finally read the temperature.  In this experiment, we will use this
temperature sensor to measure the temperature in the current
environment. The test result is **℃**, ranging from -55**℃** to
+125**℃**. We will display the test result on shell.

**2. Working Principle**

The hardware interface of the 1-Wire bus is very simple, just connect
the data pin of the DS18B20 to an IO port of the microcontroller. The
timing of the 1-Wire bus is relatively complex. Many students can’t
understand the timing diagram independently here. We have encapsulated
the complex timing operations in the library, and you can use the
library functions directly.

Schematic Diagram of DS18B20

This can save up to 12-bit temperature vale. In the register, save in
code complement. As shown below;

![](media/bffba8c519ff6e0310882d0712be9177.png)

A total of 2 bytes, LSB is the low byte, MSB is the high byte, where MSb
is the high byte of the byte, LSb is the low byte of the byte. As you
can see, the binary number, the meaning of the temperature represented
by each bit, is expressed. Among them, S represents the sign bit, and
the lower 11 bits are all powers of 2, which are used to represent the
final temperature. The temperature measurement range of DS18B20 is from
-55 degrees to +125 degrees, and the expression form of temperature
data, S represents positive and negative temperature, and the resolution
is 2﹣⒋, which is 0.0625.

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/d892bdfa25f3544ae28aa16d8b1b3c50.png" style="width:0.98056in;height:0.73542in" alt="18B20温度传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio 18B20 Temperature Sensor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/f605610384d05ff2877e58474a0d6f81.png)

**5. Add Library**

Open Thonny, click “This computer”→“D:”→“2.
ESP32\_code\_MicroPython”→“lesson 34. DS18B20”.
Select“ds18x20.py”and“onewire.py”，right-click and select“Upload to
/”

![](media/46965c2491db8e549930d841791815e3.png)

![](media/7e6a0b05a3d8bf17b6a39db85530ddfb.png)

**6.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>import machine, onewire, ds18x20, time</p>
<p>ds_pin = machine.Pin(15)</p>
<p>ds_sensor = ds18x20.DS18X20(onewire.OneWire(ds_pin))</p>
<p>roms = ds_sensor.scan()</p>
<p>print('Found DS devices: ', roms)</p>
<p>while True:</p>
<p>ds_sensor.convert_temp()</p>
<p>time.sleep_ms(750)</p>
<p>for rom in roms:</p>
<p>#print(rom)</p>
<p>print(ds_sensor.read_temp(rom))</p>
<p>time.sleep(1)</p></td>
</tr>
</tbody>
</table>

**7. Code Explanation**

1.  We set the pin to GPIO15 and obtain the temperature in the unit of
    ℃.  

2\. The Shell window displays the temperature value. Ds\_sensor.
Read\_temp (ROM) indicates the temperature value.

 

**8. Test Result**

Wire up, power up and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. the shell displays the temperature of the
current environment, as shown below. Press “Ctrl+C”or
click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/d1e1bcf43e4a7562c4e4f69230c84b47.png)

### Project 35: XHT11 Temperature and Humidity Sensor

![](media/1153b275e0f6c086c9e4225084acf246.png)

1.  **Description**

This DHT11 temperature and humidity sensor is a composite sensor which
contains a calibrated digital signal output of the temperature and
humidity.

DHT11 temperature and humidity sensor uses the acquisition technology of
the digital module and temperature and humidity sensing technology,
ensuring high reliability and excellent long-term stability.

It includes a resistive element and a NTC temperature measuring device.

![](media/ac0d6049bc0a5ae8cc515d23b85ecad0.png)

**2. Working Principle**

The communication and synchronization between the single-chip
microcomputer and XHT11 adopts the single bus data format. The
communication time is about 4ms. The data is divided into fractional
part and integer part.

Operation process: A complete data transmission is 40bit, high bit first
out. Data format: 8bit humidity integer data + 8bit humidity decimal
data + 8bit temperature integer data + 8bit temperature decimal data +
8bit checksum

8-bit checksum: 8-bit humidity integer data + 8-bit humidity decimal
data + 8-bit temperature integer data + 8-bit temperature decimal data
"Add the last 8 bits of the result.

**3. Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.22639in;height:0.93958in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/04f2996e6e2b0d8d4b5158728a23e905.png" style="width:0.88472in;height:0.66875in" alt="33.温湿度" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio XHT11 Temperature and Humidity Sensor*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/7e2c1d38e5a419a5df8489869a94d21c.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import machine, time and dht modules.</p>
<p>import machine</p>
<p>import time</p>
<p>import dht</p>
<p>#Associate DHT11 with Pin(15).</p>
<p>DHT = dht.DHT11(machine.Pin(15))</p>
<p># Obtain temperature and humidity data once per second and print them out.</p>
<p>while True:</p>
<p>DHT.measure() # Start DHT11 to measure data once.</p>
<p># Call the built-in function of DHT to obtain temperature</p>
<p># and humidity data and print them in “Shell”.</p>
<p>print('temperature:',DHT.temperature(),'℃','humidity:',DHT.humidity(),'%')</p>
<p>time.sleep_ms(1000)</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The shell displays the temperature and
humidity data of the current environment, as shown below.
Press“Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to
exit the program.

![](media/10e74fe20d6fd681f645449217a508e8.png)

### Project 36: DS1307 Clock Module

![](media/949abbbea3c8d8b36463768a39a07b51.png)

1.  **Overview**

This module mainly uses the real-time clock chip DS1307, which is the
I2C bus interface chip that has second, minute, hour, day, month, year
and other functions as well as leap year automatic adjustment function
introduced by DALLAS. It can work independently of CPU, and won‘t’
affected by the CPU main crystal oscillator and capacitance as well as
keep accurate time. What‘s more, monthly cumulative error is generally
less than 10 seconds.The chip also has a clock protection circuit in
case of main power failure and runs on a back-up battery that denies the
CPU read and write access. At the same time, it contains automatic
switching control circuit of standby power supply, so it can guarantee
the accuracy of system clock in case of power failure of main power
supply and other bad environment.

Going forward, the DS1307 chip internal integration has a certain
capacity, with power failure protection characteristics of static RAM,
which can be used to save some key data. 

![](media/92b8dc82b0c2887539bd506639cfbfc0.png)In the experiment, we use the DS1307 clock
module to obtain the system time and print the test results.  

**2. Working Principle**

Serial real-time clock records year, month, day, hour, minute, second
and week; AM and PM indicate morning and afternoon respectively; 56
bytes of NVRAM store data; 2-wire serial port; programmable square wave
output; power failure detection and automatic switching circuit; battery
current is less than 500nA.

Pins description：X1, 32.768kHz crystal terminal ;

VBAT:X2：+3V input;

SDA：serial data;

SCL：serial clock;

SQW/OUT：square waves/output drivers

![](media/abdebbfc01cae240e3e81fb188344cbe.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/44d6a0e867ad07a9a9733ce42a9d488a.png" style="width:0.90208in;height:0.44583in" alt="KS6072 keyestudio传感器 keyestudio 2021新款 DIY电子积木 DS1307时钟传感器模块 黑色环保 矢量图" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio DS1307 Clock Module*1</td>
<td>4P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/de4d2418a1b8ed0ae1c466747103a440.png)

**5. Add Library**

Open “Thonny”, click“This computer”→“D:”→“2.
ESP32\_code\_MicroPython”→“lesson 36. DS1307 Real Time Clock”.
Select“urtc.py”，right-click and select“Upload to /”，wait for
the“urtc.py”to be uploaded to the ESP32.

![](media/54019debbb299ba27d3cf54ce3b00316.png)

**6.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import I2C, Pin</p>
<p>from urtc import DS1307</p>
<p>import utime</p>
<p>i2c = I2C(1,scl = Pin(22),sda = Pin(21),freq = 400000)</p>
<p>rtc = DS1307(i2c)</p>
<p>year = int(input("Year : "))</p>
<p>month = int(input("month (Jan --&gt; 1 , Dec --&gt; 12): "))</p>
<p>date = int(input("date : "))</p>
<p>day = int(input("day (1 --&gt; monday , 2 --&gt; Tuesday ... 0 --&gt; Sunday): "))</p>
<p>hour = int(input("hour (24 Hour format): "))</p>
<p>minute = int(input("minute : "))</p>
<p>second = int(input("second : "))</p>
<p>now = (year,month,date,day,hour,minute,second,0)</p>
<p>rtc.datetime(now)</p>
<p>#(year,month,date,day,hour,minute,second,p1) = rtc.datetime()</p>
<p>while True:</p>
<p>DateTimeTuple = rtc.datetime()</p>
<p>print(DateTimeTuple[0], end = '-')</p>
<p>print(DateTimeTuple[1], end = '-')</p>
<p>print(DateTimeTuple[2], end = ' ')</p>
<p>print(DateTimeTuple[4], end = ':')</p>
<p>print(DateTimeTuple[5], end = ':')</p>
<p>print(DateTimeTuple[6], end = ' week:')</p>
<p>print(DateTimeTuple[3])</p>
<p>utime.sleep(1)</p></td>
</tr>
</tbody>
</table>

**7. Code Explanation**

**rtc.datetime()：**Return a tuple of time. When the program is running,
we set the "please input" program, run the code, it will prompt us to
input the time and date, after the input is completed, the data will be
printed every second.

**DateTimeTuple\[0\]:** save years

**DateTimeTuple\[1\]:** save months

**DateTimeTuple\[2\]**: save days

**DateTimeTuple\[3\]**: save weeks

**Rtc.GetDateTime().Month():** return months

**DateTimeTuple\[4\]:** save hours

**DateTimeTuple\[5\]**: save minutes

**DateTimeTuple\[6\]:** save seconds

**8. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts

executing. the shell will display“Year:”. Then we enter year, month,day,
hour, minute and second,once complete, printed the data every second, as
shown below. Press “Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

![](media/db5ed7d9d70655d0d4347aed286c76dd.png)

### Project 37: TM1650 4-Digit Tube Display

![](media/f698ea56391906278b7c8064fca42bb3.jpeg)

**1. Overview**

This module is mainly composed of a 0.36 inch red common anode 4-digit
digital tube, and its driver chip is TM1650. When using it, we only need
two signal lines to make the single-chip microcomputer control a
4-bitdigit tube, which greatly saves the IO port resources of the
control board.

TM1650 is a special circuit for LED (light emitting diode display) drive
control. It integrates MCU input and output control digital interface,
data latch, LED drivers, keyboard scanning, brightness adjustment and
other circuits.

TM1650 has stable performance, reliable quality and strong
anti-interference ability.

It can be applied to the application of long-term continuous working for
24 hours.

TM1650 uses 2-wire serial transmission protocol for communication (note
that this data transmission protocol is not a standard I2C protocol).
The chip can drive the digital tube and save MCU pin resources through
two pins and MCU communication.

**2. Working Principle**

TM1650 adopts IIC treaty, which uses DIO and CLK buses.

![](media/c7b895791863dfc2663800ce90f61c89.png)

**Data command setting**: 0x48 means that we light up the digital tube,
instead of enable the function of key scanning

![](media/09585b52bed3d4112d59a611c3c3f262.png)

**Command display setting:**

bit\[6:4\]：set the brightness of tube display, and 000 is brightest

bit\[3\]：set to show decimal points

bit\[0\]：start the display of the tube display

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f47b077303226cce504ea7734826dfc9.png" style="width:0.94514in;height:0.52569in" alt="四位数码管模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio TM16504-Digit Segment Display*1</td>
<td>4P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/08a0d34d55b5e4215c77fbf8f656c9a9.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p># definitions for TM1650</p>
<p>ADDR_DIS = 0x48 #mode command</p>
<p>ADDR_KEY = 0x49 #read key value command</p>
<p># definitions for brightness</p>
<p>BRIGHT_DARKEST = 0</p>
<p>BRIGHT_TYPICAL = 2</p>
<p>BRIGHTEST = 7</p>
<p>on = 1</p>
<p>off = 0</p>
<p># number:0~9</p>
<p>NUM = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f]</p>
<p># DIG = [0x68,0x6a,0x6c,0x6e]</p>
<p>DIG = [0x6e,0x6c,0x6a,0x68]</p>
<p>DOT = [0,0,0,0]</p>
<p>clkPin = 22</p>
<p>dioPin = 21</p>
<p>clk = Pin(clkPin, Pin.OUT)</p>
<p>dio = Pin(dioPin, Pin.OUT)</p>
<p>DisplayCommand = 0</p>
<p>def writeByte(wr_data):</p>
<p>global clk,dio</p>
<p>for i in range(8):</p>
<p>if(wr_data &amp; 0x80 == 0x80):</p>
<p>dio.value(1)</p>
<p>else:</p>
<p>dio.value(0)</p>
<p>clk.value(0)</p>
<p>time.sleep(0.0001)</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>clk.value(0)</p>
<p>wr_data &lt;&lt;= 1</p>
<p>return</p>
<p>def start():</p>
<p>global clk,dio</p>
<p>dio.value(1)</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>dio.value(0)</p>
<p>return</p>
<p>def ack():</p>
<p>global clk,dio</p>
<p>dy = 0</p>
<p>clk.value(0)</p>
<p>time.sleep(0.0001)</p>
<p>dio = Pin(dioPin, Pin.IN)</p>
<p>while(dio.value() == 1):</p>
<p>time.sleep(0.0001)</p>
<p>dy += 1</p>
<p>if(dy&gt;5000):</p>
<p>break</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>clk.value(0)</p>
<p>dio = Pin(dioPin, Pin.OUT)</p>
<p>return</p>
<p>def stop():</p>
<p>global clk,dio</p>
<p>dio.value(0)</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>dio.value(1)</p>
<p>return</p>
<p>def displayBit(bit, num):</p>
<p>global ADDR_DIS</p>
<p>if(num &gt; 9 and bit &gt; 4):</p>
<p>return</p>
<p>start()</p>
<p>writeByte(ADDR_DIS)</p>
<p>ack()</p>
<p>writeByte(DisplayCommand)</p>
<p>ack()</p>
<p>stop()</p>
<p>start()</p>
<p>writeByte(DIG[bit-1])</p>
<p>ack()</p>
<p>if(DOT[bit-1] == 1):</p>
<p>writeByte(NUM[num] | 0x80)</p>
<p>else:</p>
<p>writeByte(NUM[num])</p>
<p>ack()</p>
<p>stop()</p>
<p>return</p>
<p>def clearBit(bit):</p>
<p>if(bit &gt; 4):</p>
<p>return</p>
<p>start()</p>
<p>writeByte(ADDR_DIS)</p>
<p>ack()</p>
<p>writeByte(DisplayCommand)</p>
<p>ack()</p>
<p>stop()</p>
<p>start()</p>
<p>writeByte(DIG[bit-1])</p>
<p>ack()</p>
<p>writeByte(0x00)</p>
<p>ack()</p>
<p>stop()</p>
<p>return</p>
<p>def setBrightness(b = BRIGHT_TYPICAL):</p>
<p>global DisplayCommand,brightness</p>
<p>DisplayCommand = (DisplayCommand &amp; 0x0f)+(b&lt;&lt;4)</p>
<p>return</p>
<p>def setMode(segment = 0):</p>
<p>global DisplayCommand</p>
<p>DisplayCommand = (DisplayCommand &amp; 0xf7)+(segment&lt;&lt;3)</p>
<p>return</p>
<p>def displayOnOFF(OnOff = 1):</p>
<p>global DisplayCommand</p>
<p>DisplayCommand = (DisplayCommand &amp; 0xfe)+OnOff</p>
<p>return</p>
<p>def displayDot(bit, OnOff):</p>
<p>if(bit &gt; 4):</p>
<p>return</p>
<p>if(OnOff == 1):</p>
<p>DOT[bit-1] = 1;</p>
<p>else:</p>
<p>DOT[bit-1] = 0;</p>
<p>return</p>
<p>def InitDigitalTube():</p>
<p>setBrightness(2)</p>
<p>setMode(0)</p>
<p>displayOnOFF(1)</p>
<p>for _ in range(4):</p>
<p>clearBit(_)</p>
<p>return</p>
<p>def ShowNum(num): #0~9999</p>
<p>displayBit(1,num%10)</p>
<p>if(num &lt; 10):</p>
<p>clearBit(2)</p>
<p>clearBit(3)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 9 and num &lt; 100):</p>
<p>displayBit(2,num//10%10)</p>
<p>clearBit(3)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 99 and num &lt; 1000):</p>
<p>displayBit(2,num//10%10)</p>
<p>displayBit(3,num//100%10)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 999 and num &lt; 10000):</p>
<p>displayBit(2,num//10%10)</p>
<p>displayBit(3,num//100%10)</p>
<p>displayBit(4,num//1000)</p>
<p>InitDigitalTube()</p>
<p>while True:</p>
<p>#displayDot(1,on) # on or off, DigitalTube.Display(bit,number); bit=1---4 number=0---9</p>
<p>for i in range(0,9999):</p>
<p>ShowNum(i)</p>
<p>time.sleep(0.01)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

**clkPin = 22、dioPin = 21is pin number**，CLK is connected to GPIO22，DIO
is connected to GPIO21. We can set any two pins at random.

**displayBit(bit, num):** show numbers at bit(1\~4) bit num(0\~9)

**clearBit(bit): clear up** bit(1\~4)

**setBrightness(): brightness setting**

**displayOnOFF()** 0 means OFF, 1 means ON

**displayDot(bit, OnOff)**shows dots，0 means OFF, 1 means ON

**ShowNum(num): show integer** num，in the range of 0\~9999

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The 4-digit tube display will show numbers
from 0 to 99999, an increase of 1 for each 10ms, then start from 0
again. Press“Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

### Project 38: HT16K33\_8X8 Dot Matrix Module

![](media/431b6c4abd63b99219658a03d24de991.jpeg)

1.  **Overview**

What is the dot matrix display?

The 8X8 dot matrix is composed of 64 light-emitting diodes, and each
light-emitting diode is placed at the intersection of the row line and
the column line. When the corresponding row is set to 1 level, and a
certain column is set to 0 level, the corresponding diode will light up.

**2. Working Principle**

As the schematic diagram shown, to light up the LED at the first row and
column, we only need to set C1 to high level and R1 to low level. To
turn on LEDs at the first row, we set R1 to low level and C1-C8 to high
level.

16 IO ports are needed, which will highly waste the MCU resources.

Therefore, we designed this module, using the HT16K33 chip to drive an
8\*8 dot matrix, which greatly saves the resources of the single-chip
microcomputer.

There are three DIP switches on the module, all of which are set to I2C
communication address. The setting method is shown below. A0，A1 and A2
are grounded, that is, the address is 0x70

<table>
<tbody>
<tr class="odd">
<td>A0（1）</td>
<td>A1（2）</td>
<td>A2（3）</td>
<td>A0（1）</td>
<td>A1（2）</td>
<td>A2（3）</td>
<td>A0（1）</td>
<td>A1（2）</td>
<td>A2（3）</td>
</tr>
<tr class="even">
<td>0（OFF）</td>
<td>0（OFF）</td>
<td>0（OFF）</td>
<td>1（ON）</td>
<td>0（OFF）</td>
<td>0（OFF）</td>
<td>0（OFF）</td>
<td>1（ON）</td>
<td>0（OFF）</td>
</tr>
<tr class="odd">
<td>OX70</td>
<td>OX71</td>
<td>OX72</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>A0（1）</td>
<td>A1（2）</td>
<td>A2（3）</td>
<td>A0（1）</td>
<td>A1（2）</td>
<td>A2（3）</td>
<td>A0（1）</td>
<td>A1（2）</td>
<td>A2（3）</td>
</tr>
<tr class="odd">
<td>1（ON）</td>
<td>1（ON）</td>
<td>0（OFF）</td>
<td>0（OFF）</td>
<td>0（OFF）</td>
<td>1（ON）</td>
<td>1（ON）</td>
<td>0（OFF）</td>
<td>1（ON）</td>
</tr>
<tr class="even">
<td>OX73</td>
<td>OX74</td>
<td>OX75</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>A0（1）</td>
<td>A1（2）</td>
<td>A2（3）</td>
<td>A0（1）</td>
<td>A1（2）</td>
<td>A2（3）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>0（OFF）</td>
<td>1（ON）</td>
<td>1（ON）</td>
<td>1（ON）</td>
<td>1（ON）</td>
<td>1（ON）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>OX76</td>
<td>OX77</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/713307c9cb50d067a014dee9522afe15.png" style="width:0.99722in;height:0.49861in" alt="_8X8点阵模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td><p>Keyestudio HT16K33_</p>
<p>8X8 Dot Matrix*1</p></td>
<td>4P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/d3f2f2968ff861d04e909cf330986652.png)

**5. Add Library**

Open“This computer”→“D:”→“2. ESP32\_code\_MicroPython”→“lesson 38.
HT16K33 dot matrix”. Select“ht16k33.py”and“ht16k33matrix.py”，right-click
and select“Upload to /”，waiting for
the“ht16k33.py”and“ht16k33matrix.py”to be uploaded to the ESP32.

![](media/72d1aef422351dbe8219787119fa7387.png)

![](media/80be0d6353d8cf40a21f05c25bb69c45.png)

**6.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># IMPORTS</p>
<p>import utime as time</p>
<p>from machine import I2C, Pin, RTC</p>
<p>from ht16k33matrix import HT16K33Matrix</p>
<p># CONSTANTS</p>
<p>DELAY = 0.01</p>
<p>PAUSE = 3</p>
<p># START</p>
<p>if __name__ == '__main__':</p>
<p>i2c = I2C(scl=Pin(22), sda=Pin(21))</p>
<p>display = HT16K33Matrix(i2c)</p>
<p>display.set_brightness(2)</p>
<p># Draw a custom icon on the LED</p>
<p>icon = b"\x00\x66\x00\x00\x18\x42\x3c\x00"</p>
<p>display.set_icon(icon).draw()</p>
<p># Rotate the icon</p>
<p>display.set_angle(0).draw()</p>
<p>time.sleep(PAUSE)</p></td>
</tr>
</tbody>
</table>

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing.The dot matrix displays a“ smile ”pattern.
Press “Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to
exit the program.

### Project 39: RFID Module

![](media/75003b61112e3495f213629e49f26185.jpeg)

1.  **Description**

RFIDRFID-RC522 radio frequency module adopts a Philips MFRC522 original
chip to design card reading circuit, easy to use and low cost, suitable
for equipment development and card reader development and so on.

RFID or Radio Frequency Identification system consists of two main
components, a transponder/tag attached to an object to be identified,
and a transceiver also known as interrogator/Reader.

In the experiment, the data read by the card swipe module is 4
hexadecimal numbers, and we print these four hexadecimal numbers as
strings. For example, we read the data of the IC card below: 237,
247,148,90 and the data read from the keychain is: 76, 9, 107, 110.
Different IC cards and different key chains have diverse data.

**2. Working Principle**

Radio frequency identification, the card reader is composed of a radio
frequency module and a high-level magnetic field. The Tag transponder is
a sensing device, and this device does not contain a battery. It only
contains tiny integrated circuit chips and media for storing data and
antennas for receiving and transmitting signals. To read the data in the
tag, first put it into the reading range of the card reader. The reader
will generate a magnetic field, and because the magnetic energy
generates electricity according to Lenz's law, the RFID tag will supply
power, thereby activating the device.

![](media/8f1b325813b0fe4f6b0fd1e6f02a9405.png)

**3.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/7a92817c3717215f6f9d73dbeb6d2285.png" style="width:1.38542in;height:0.68611in" alt="RFID 新" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio RFID Module*1</td>
<td>4P Dupont Wire*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/decf08b83c5594f7f1e51f6e93051f4b.png" style="width:1.30208in;height:0.69722in" alt="3 (2)" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/2a40c5c68dc7802d29bcf719bb688f64.png" style="width:1.3in;height:0.81806in" alt="门卡2" /></td>
<td></td>
</tr>
<tr class="even">
<td>Micro USB Cable*1</td>
<td>Key*1</td>
<td>IC Card*1</td>
<td></td>
</tr>
</tbody>
</table>

**4.Wiring Diagram**

![](media/33c691a71bc8a173a6b775b86c2c2f02.png)

**5. Add Library**

Open“Thonny”, click“This computer”→“D:”→“2.
ESP32\_code\_MicroPython”→“lesson 39. RFID RC522”.
Select“mfrc522\_config.py”，“mfrc522\_i2c.py”and
“soft\_iic.py”，right-click and select“Upload to /”，waiting for the
“mfrc522\_config.py”，“mfrc522\_i2c.py”and “soft\_iic.py”to be uploaded
to the ESP32.

![](media/cb53fea1ae89f414ff34fa3367fdb69d.png)

![](media/0eea97788faf1e67b3968c55d0ba0974.png)

![](media/d83d90e285a39ada783bf785cec465d1.png)

**6.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>import machine</p>
<p>import time</p>
<p>from mfrc522_i2c import mfrc522</p>
<p>#i2c config</p>
<p>addr = 0x28</p>
<p>scl = 22</p>
<p>sda = 21</p>
<p>rc522 = mfrc522(scl, sda, addr)</p>
<p>rc522.PCD_Init()</p>
<p>rc522.ShowReaderDetails() # Show details of PCD - MFRC522 Card Reader details</p>
<p>while True:</p>
<p>if rc522.PICC_IsNewCardPresent():</p>
<p>#print("Is new card present!")</p>
<p>if rc522.PICC_ReadCardSerial() == True:</p>
<p>print("Card UID:")</p>
<p>print(rc522.uid.uidByte[0 : rc522.uid.size])</p>
<p>#time.sleep(1)</p></td>
</tr>
</tbody>
</table>

**7. Code Explanation**

**mfrc522\_config.py;** This is a configuration file that defines some
parameters and commands

**mfrc522\_i2c.py;** Initialization and read and write functions

**Soft\_iic.py;** It is the bottom-level read and write function of
software I2C. We use the io port to simulate I2C here.

**8. Test Result**

Wire up and power on. Click![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. When we make the IC card and key chain close
to the RFID module, the information will be printed out, as shown in the
figure below. Press “Ctrl+C”or click
![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/e962f53434970e05a2136bd3ad67dd45.png)

Note: Different **RFID-RC522** door cards and key chains have diverse
values.

**4. Comprehensive Experiments**

The previous projects are related to single sensors or modules. In the
following part, we will combine various sensors and modules to create
some comprehensive experiments to perform special functions.

### Project 40: Button-controlled LED

![](media/50740b22d16151d490b8494b0bff4f6e.jpeg)

**1. Overview**

In this lesson, we will make an extension experiment with a button and
an LED. When the button is pressed and low levels are output, the LED
will light up; when the button is released, the LED will go off. Then we
can control a module with another module.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.07222in;height:0.82153in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f0ef7a5a2e7eebb09e91f73cb2a6caf3.png" style="width:0.57014in;height:0.75972in" alt="白色LED模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/1aafa8910f5184973f1c913c19489fbd.png" style="width:0.57292in;height:0.76389in" alt="单路按键模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Purple LED Module*1</td>
<td>Keyestudio Button Module*1</td>
<td>3P Dupont Wire*2</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/378de9cb95275a6a1dec9adbf2f15eaa.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>led = Pin(4, Pin.OUT) # create LED object from Pin 4,Set Pin 4 to output</p>
<p>button = Pin(15, Pin.IN, Pin.PULL_UP) #Create button object from Pin15,Set GP15 to input</p>
<p>#Customize a function and name it reverseGPIO(),which reverses the output level of the LED</p>
<p>def reverseGPIO():</p>
<p>if led.value():</p>
<p>led.value(0) #Set led turn off</p>
<p>else:</p>
<p>led.value(1) #Set led turn on</p>
<p>try:</p>
<p>while True:</p>
<p>if not button.value():</p>
<p>time.sleep_ms(20)</p>
<p>if not button.value():</p>
<p>reverseGPIO()</p>
<p>while not button.value():</p>
<p>time.sleep_ms(20)</p>
<p>except:</p>
<p>pass</p></td>
</tr>
</tbody>
</table>

**5. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. When the button is pressed, the LED will
light up; when pressed again, the LED will go off., cycle this
operation. Press“Ctrl+C”or “Stop/Restart backend”to exit the program.

### Project 41: Alarm Experiment

![](media/6db3cb7d3a91e700a3b651c1f0edb7a5.jpeg)

1.  **Overview**

In the previous experiment, we control an output module though an input
module. In this lesson, we will make an experiment that the active
buzzer will emit sounds once an obstacle appears.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.05556in;height:0.80903in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/ac83d2c470cd6c345f17feed3bce5358.png" style="width:0.56042in;height:0.80556in" alt="避障传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/cbc890daba907eee365bdaacf1f509a8.png" style="width:0.53056in;height:0.70764in" alt="有源蜂鸣器模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.08819in;height:0.45208in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Obstacle Avoidance Sensor*1</td>
<td>Keyestudio Active Buzzer*1</td>
<td>3P Dupont Wire*2</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/e37efdec9676d47eaf8dabd2da41759a.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>buzzer = Pin(4, Pin.OUT)</p>
<p>sensor = Pin(15, Pin.IN)</p>
<p>while True:</p>
<p>buzzer.value(not(sensor.value()))</p>
<p>time.sleep(0.01)</p></td>
</tr>
</tbody>
</table>

**5. Code Explanation**

When an obstacle is detected, sensor.value() will return a low level
signal. So when an obstacle is detected, the GPIO4 connected to the
buzzer pin will output a high level signal, the buzzer will emit sounds.

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The active buzzer will emit sound if
detecting obstacles; otherwise, it won’t emit sound. Press “Ctrl+C” or
click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend” to exit the program.

### Project 42: Intrusion Detection

![](media/b7828b9e5ee615a151567e20d35db90f.png)

1.  **Description**

In this experiment, we use a PIR motion sensor to control an active
buzzer to emit sounds and the onboard LED to flash rapidly.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/256a8301b740dfb2981a635a4b575ba0.png" style="width:0.57431in;height:0.76458in" alt="人体红外热释传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/cbc890daba907eee365bdaacf1f509a8.png" style="width:0.59028in;height:0.7875in" alt="有源蜂鸣器模块" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio PIR Motion Sensor*1</td>
<td>Keyestudio Active Buzzer*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/12ecb079cf6481a6f0f04d6b7bb31fd8.png" style="width:0.70417in;height:0.93889in" alt="白色LED模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.89722in;height:0.37292in" alt="USB线" /></td>
<td></td>
</tr>
<tr class="even">
<td>Keyestudio Purple LED Module*1</td>
<td>3P Dupont Wire*3</td>
<td>Micro USB Cable*1</td>
<td></td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/07ded8ae2b9b12d7d399422cae6b8c5a.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin and time modules.</p>
<p>from machine import Pin</p>
<p>import time</p>
<p># Define the pins of the Human infrared sensor,led and Active buzzer.</p>
<p>sensor_pir = Pin(15, Pin.IN)</p>
<p>led = Pin(22, Pin.OUT)</p>
<p>buzzer = Pin(4, Pin.OUT)</p>
<p>while True:</p>
<p>if sensor_pir.value():</p>
<p>print("Warning! Intrusion detected！")</p>
<p>buzzer.value(1)</p>
<p>led.value(1)</p>
<p>time.sleep(0.2)</p>
<p>buzzer.value(0)</p>
<p>led.value(0)</p>
<p>time.sleep(0.2)</p>
<p>else:</p>
<p>buzzer.value(0)</p>
<p>led.value(0)</p></td>
</tr>
</tbody>
</table>

**5. Test Result**

Wire up and power on. Click![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. If the PIR sensor detects someone moving
nearby, the buzzer will emit an alarm , and the LED will flash
continuously. At the same time, the“shell” will diaplay “Warning\!
Intrusion detected\!”Press“Ctrl+C”or click
![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/8d9889d04e7080f918446cc8a23d05e8.png)

### Project 43: Extinguishing Robot

![](media/a3ccd8168b26f2a183fa9feda1b015f3.jpeg)

1.  **Description**

Today we will use Arduino simulation to build an extinguishing robot
that will automatically sense the fire and start the fan. In this
project we will learn how to build a very simple robot using ESP32,
(detecting flames with a flame sensor, blowing out candles with a fan)
can teach us basic concepts about robotics. Once you understand the
basics below, you can build more complex robots.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/7fb69d426cee60c976f9ef2c1e410480.png" style="width:0.84375in;height:0.72083in" alt="KS6038 130电机驱动模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/8c01c41beb7791380b223f244cd08e87.png" style="width:0.84653in;height:0.50764in" alt="火焰传感器" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio 130 Motor*1</td>
<td>Keyestudio Flame Sensor*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.90556in;height:0.48542in" alt="USB线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b65d826ca481982fed0212dba2957c7c.jpeg" style="width:1.57361in;height:1.13611in" alt="123" /></td>
</tr>
<tr class="even">
<td>3P Dupont Wire*1</td>
<td>4P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
<td>6 AA Battery Holder*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a815c48437199c6ab79d74cd2d583de0.png" style="width:0.30417in;height:1.40069in" /></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>AA Battery(not included)*6</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/68f8fee9c39dad76e1eb3e783ddc1c37.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin and ADCmodules.</p>
<p>from machine import ADC,Pin</p>
<p>import time</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p>#Two pins of the moto</p>
<p>INA = Pin(15, Pin.OUT) #INA corresponds to IN+</p>
<p>INB = Pin(4, Pin.OUT) #INB corresponds to IN-</p>
<p>while True:</p>
<p>adcVal=adc.read()</p>
<p>print(adcVal)</p>
<p>if adcVal &lt; 3000:</p>
<p>#open</p>
<p>INA.value(0)</p>
<p>INB.value(1)</p>
<p>else:</p>
<p>#stop</p>
<p>INA.value(0)</p>
<p>INB.value(0)</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**5. Code Explanation**

In the code, we set the threshold value to 3000. When the ADC value
detected by the flame sensor is lower than the threshold value, the fan
will be automatically turned on; otherwise, it will be turned off. For
the driving method of the fan, please refer to the 130 Motor.

**6. Test Result**

Wire up, power on and turn the DIP switch to the ON end, click
![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”, the code starts executing.
The shell prints the flame value. When this value is less than 3000, the
fan will work to blow out the fire. Basically, the flame value can be
set by yourself. Press “Ctrl+C”or click
![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

![](media/8f2627aa51c2f1620c4f2b9b6f3abf4c.png)

### Project 44: Rotary Encoder control RGB

![](media/c6b4f1cedef06ed68d1c2e5ccf5c17d2.jpeg)

1.  **Introduction**

In this lesson, we will control the LED on the RGB module to show
different colors through a rotary encoder.

When designing the code, we need to divide the obtained values by 3 to
get the remainders. The remainder is 0 and the LED will become red. The
remainder is 1, the LED will become green. The remainder is 2, the LED
will turn blue.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/eb9d1b363af72bc105ce38cb9e4d99b1.png" style="width:0.73472in;height:0.98125in" alt="共阴RGB模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/989ee8ccd2a016dcaeb0bef68d55e912.png" style="width:0.97778in;height:0.73333in" alt="旋转编码器模块" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td><p>Keyestudio</p>
<p>Common Cathode RGB Module*1</p></td>
<td><p>Keyestudio</p>
<p>Rotary Encoder Module*1</p></td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/fc3fd9c0110b04d1af77a2ff8c01a10a.png" style="width:1.36806in;height:0.57361in" alt="5p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:1.46875in;height:0.57222in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.89722in;height:0.37292in" alt="USB线" /></td>
<td></td>
</tr>
<tr class="even">
<td>5P Dupont Wire*1</td>
<td>4P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
<td></td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/c88ef3fa9019777e0697e242d0b41c4c.png)

**4. Add Library**

Open“Thonny”, click “This computer”→“D:”→“2.
ESP32\_code\_MicroPython”→”lesson 44. Encoder control RGB”.
Select“rotary.py”and“rotary\_irq\_rp2.py”，right-click and
select“Upload to /”，waiting for the
“rotary.py”and“rotary\_irq\_rp2.py”to be uploaded to the ESP32.

![](media/d318fb0e39f0aa969fd9cfc398223900.png)

![](media/19520bc6a235fb1da3355b8acbd6f11c.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>import time</p>
<p>from rotary_irq_rp2 import RotaryIRQ</p>
<p>from machine import Pin, PWM</p>
<p>pwm_r = PWM(Pin(0))</p>
<p>pwm_g = PWM(Pin(2))</p>
<p>pwm_b = PWM(Pin(15))</p>
<p>pwm_r.freq(1000)</p>
<p>pwm_g.freq(1000)</p>
<p>pwm_b.freq(1000)</p>
<p>def light(red, green, blue):</p>
<p>pwm_r.duty(red)</p>
<p>pwm_g.duty(green)</p>
<p>pwm_b.duty(blue)</p>
<p>SW=Pin(27,Pin.IN,Pin.PULL_UP)</p>
<p>r = RotaryIRQ(pin_num_clk=12,</p>
<p>pin_num_dt=14,</p>
<p>min_val=0,</p>
<p>reverse=False,</p>
<p>range_mode=RotaryIRQ.RANGE_UNBOUNDED)</p>
<p>while True:</p>
<p>val = r.value()</p>
<p>print(val%3)</p>
<p>if val%3 == 0:</p>
<p>light(4950, 0, 0)</p>
<p>elif val%3 == 1:</p>
<p>light(0, 4950, 0)</p>
<p>elif val%3 == 2:</p>
<p>light(0, 0, 4950)</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

In the experiment, we set the val to the remainder of Encoder\_Count
divided by 3. Encoder\_Count is the value of the encoder. Then we can
set pin GPIO0 (red), GPIO2 (green) and GPIO15 (blue) according to
remainders.

Colors of the LEDs can be controlled by remainders.

**7. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. Rotate the knob of the rotary encoder to
display the reminders, which can control colors of LED(red green blue).
Press “Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend” to
exit the program.

![](media/6894e2afd1eb7e150457048e0174adf8.png)

### Project 45: Rotary Potentiometer

![](media/f71165ab140ae6b2aac093dc75785c96.jpeg)

1.  **Introduction**

In the previous courses, we did experiments of breathing light and
controlling LED with button. In this course, we do these two experiments
by controlling the brightness of LED through an adjustable
potentiometer. The brightness of LED is controlled by PWM values, and
the range of analog values is 0 to 4095 and the PWM value range is
0-255.

After the code is set successfully, we can control the brightness of the
LED on the module by rotating the potentiometer.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.01528in;height:0.77778in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f0ef7a5a2e7eebb09e91f73cb2a6caf3.png" style="width:0.6375in;height:0.84931in" alt="白色LED模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a0eebfcd8f84c3fbac526e9910e66692.png" style="width:0.61667in;height:0.82292in" alt="旋转电位器传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.18819in;height:0.63681in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Purple LED Module*1</td>
<td>Keyestudio Rotary Potentiometer*1</td>
<td>3P Dupont Wire*2</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/7f24723673e622d23fbe0a3cdbd21d69.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin,PWM,ADC</p>
<p>import time</p>
<p>pwm =PWM(Pin(15,Pin.OUT),1000)</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_10BIT)</p>
<p>try:</p>
<p>while True:</p>
<p>adcValue=adc.read()</p>
<p>pwm.duty(adcValue)</p>
<p>print(adc.read())</p>
<p>time.sleep_ms(100)</p>
<p>except:</p>
<p>pwm.deinit()</p></td>
</tr>
</tbody>
</table>

**5. Code Explanation**

It is easy to control the brightness of the LED light by a
potentiometer. Here we can find that MicroPython unifies the value range
of the ADC between 0 and 1023, and assigns values directly, which is
simple and convenient.

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. Rotating the potentiometer on the module can
adjust the brightness of the LED on the LED module. Press“Ctrl+C”or
click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

### Project 46: Smart Windows

![](media/fd7384d737b0393e91d42523f4d65b07.jpeg)

1.  **Description**

In life, we can see all kinds of smart products, such as smart home.
Smart homes include smart curtains, smart windows, smart TVs, smart
lights, and more. In this experiment, we use a steam sensor to detect
rainwater, and then achieve the effect of closing and opening the window
by a servo.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b64cdb5749df7d2b7dd3719216c7aff3.png" style="width:0.91458in;height:0.65417in" alt="KS6048 水滴水蒸气传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b9a96e60ed3aee985db5d4dcaf9bf38b.png" style="width:1.05833in;height:1.05069in" alt="舵机" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.94722in;height:0.41875in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Steam Sensor*1</td>
<td>Servo*1</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/8683e9990285f9eef82368857cb5b6a6.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin and ADC modules.</p>
<p>from machine import ADC,Pin,PWM</p>
<p>import time</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p>pwm = PWM(Pin(15))#Steering pin connected to GP15</p>
<p>pwm.freq(50)#20ms period, so the frequency is 50Hz</p>
<p>'''</p>
<p>Duty cycle corresponding to the Angle</p>
<p>0°----2.5%----25</p>
<p>45°----5%----51.2</p>
<p>90°----7.5%----77</p>
<p>135°----10%----102.4</p>
<p>180°----12.5%----128</p>
<p>In consideration of the error, the duty cycle is set at 1000~9000, which can smoothly rotate 0~180 degrees</p>
<p>'''</p>
<p>angle_0 = 25</p>
<p>angle_90 = 77</p>
<p>angle_180 = 128</p>
<p>while True:</p>
<p>adcVal=adc.read()</p>
<p>print(adcVal)</p>
<p>if adcVal &gt; 2000:</p>
<p>pwm.duty(angle_0)</p>
<p>time.sleep(0.5)</p>
<p>else:</p>
<p>pwm.duty(angle_180)</p>
<p>time.sleep(0.5)</p></td>
</tr>
</tbody>
</table>

**5. Code Explanation**

We can control a servo to rotate by a threshold.

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. When the sensor detects a certain amount of
water, the servo rotates to achieve the effect of closing or opening
windows. Press“Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

### Project 47: Sound Activated Light

![](media/f3ddb58e83a92a888d3e1d66f7456170.png)

1.  **Introduction**

In this lesson, we will make a smart sound activated light using a sound
sensor and an LED module. When we make a sound, the light will
automatically turn on; when there is no sound, the lights will
automatically turn off. How it works? Because the sound-controlled light
is equipped with a sound sensor, and this sensor converts the intensity
of external sound into a corresponding value. Then set a threshold, when
the threshold is exceeded, the light will turn on, and when it is not
exceeded, the light will go out.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:0.925in;height:0.42917in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:0.97569in;height:0.74792in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/cf7b54ba090f4e34025101cf9ece26d1.png" style="width:0.60903in;height:0.8125in" alt="声音传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f0ef7a5a2e7eebb09e91f73cb2a6caf3.png" style="width:0.62153in;height:0.82847in" alt="白色LED模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.94583in;height:0.44375in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Sound Sensor*1</td>
<td>Keyestudio Purple LED Module*1</td>
<td>3P Dupont Wire*2</td>
<td><p>Micro USB</p>
<p>Cable*1</p></td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/e54db9c861847ce0145accb574467c95.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import ADC, Pin</p>
<p>import time</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p>led = Pin(15,Pin.OUT)</p>
<p>while True:</p>
<p>adcVal=adc.read()</p>
<p>print(adcVal)</p>
<p>if adcVal &gt; 600:</p>
<p>led.value(1)</p>
<p>time.sleep(3)</p>
<p>else:</p>
<p>led.value(0)</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**5. Code Explanation**

We set the ADC threshold value to 600. If more than 600, LED will be on
3s; on the contrary, it will be off.

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. The shell monitor displays the corresponding
volume ADC value. When the analog value of sound is greater than 600,
the LED on the LED module will light up, otherwise it will go off.
Press“Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to
exit the program.

![](media/ea65cb86fc3c75e71eabfb1f2e16fb1e.png)

### Project 48: Fire Alarm

![](media/e6971103aaa858036b51f3165e0ccb32.jpeg)

**1. Description**

In this experiment, we will make a fire alarm system. Just use a flame
sensor to control an active buzzer to emit sounds.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a5e355d0fd3c9b18c7684a9a2b99f0a5.png" style="width:0.70625in;height:0.94167in" alt="有源蜂鸣器模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/4ecedf84c69e9264059ffd14b02592bd.png" style="width:0.95278in;height:0.57153in" alt="火焰传感器" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Active Buzzer*1</td>
<td>keyestudio Flame Sensor*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.94722in;height:0.41875in" alt="USB线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td></td>
</tr>
<tr class="even">
<td>MicroUSB线*1</td>
<td>3P Dupont Wire*1</td>
<td>4P Dupont Wire*1</td>
<td></td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/2c25672935b822ed775e665e05f72980.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import time</p>
<p>buzzer = Pin(15, Pin.OUT)</p>
<p>sensor = Pin(4, Pin.IN)</p>
<p>while True:</p>
<p>Val = sensor.value()</p>
<p>print(Val)</p>
<p>if Val == 0:</p>
<p>buzzer.value(1)</p>
<p>else:</p>
<p>buzzer.value(0)</p>
<p>time.sleep(0.5)</p></td>
</tr>
</tbody>
</table>

**5. Code Explanation**

This flame sensor uses an analog pin and a digital pin. When a flame is
detected, the digital pin outputs a low level. In this experiment we
will use the digital port.

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. When the sensor detects the flame, the
external active buzzer will emit sounds, otherwise the active buzzer
will not emit sounds. Press “Ctrl+C”or click
![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

### Project 49: Smoke Alarm

![](media/a1f72c7aa7fd3609401a1f1176b426ec.jpeg)

1.  **Description**

In this experiment, we will make a smoke alarm by a TM16504-Digit
segment module, a gas sensor and an active buzzer.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a5e355d0fd3c9b18c7684a9a2b99f0a5.png" style="width:0.70625in;height:0.94167in" alt="有源蜂鸣器模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f47b077303226cce504ea7734826dfc9.png" style="width:0.94514in;height:0.52569in" alt="四位数码管模块" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Active Buzzer*1</td>
<td>Keyestudio TM16504-Digit Segment Module*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/ee4483f37a6f3609acdb661095f4b706.png" style="width:1.04167in;height:0.52708in" alt="KS6029 MQ-2 模拟气体传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.94722in;height:0.41875in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>keyestudio Analog Gas Senso*1</td>
<td>4P Dupont Wire*2</td>
<td>4P Dupont Wire*2</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/ae8b397c9acaba3e10da3e2028797197.png)

**4.Test Code:**

<table>
<tbody>
<tr class="odd">
<td><p># Import Pin and ADC modules.</p>
<p>from machine import ADC,Pin</p>
<p>import time</p>
<p># Turn on and configure the ADC with the range of 0-3.3V</p>
<p>adc=ADC(Pin(34))</p>
<p>adc.atten(ADC.ATTN_11DB)</p>
<p>adc.width(ADC.WIDTH_12BIT)</p>
<p>buzzer = Pin(15, Pin.OUT)</p>
<p># definitions for TM1650</p>
<p>ADDR_DIS = 0x48 #mode command</p>
<p>ADDR_KEY = 0x49 #read key value command</p>
<p># definitions for brightness</p>
<p>BRIGHT_DARKEST = 0</p>
<p>BRIGHT_TYPICAL = 2</p>
<p>BRIGHTEST = 7</p>
<p>on = 1</p>
<p>off = 0</p>
<p># number:0~9</p>
<p>NUM = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f]</p>
<p># DIG = [0x68,0x6a,0x6c,0x6e]</p>
<p>DIG = [0x6e,0x6c,0x6a,0x68]</p>
<p>DOT = [0,0,0,0]</p>
<p>clkPin = 22</p>
<p>dioPin = 21</p>
<p>clk = Pin(clkPin, Pin.OUT)</p>
<p>dio = Pin(dioPin, Pin.OUT)</p>
<p>DisplayCommand = 0</p>
<p>def writeByte(wr_data):</p>
<p>global clk,dio</p>
<p>for i in range(8):</p>
<p>if(wr_data &amp; 0x80 == 0x80):</p>
<p>dio.value(1)</p>
<p>else:</p>
<p>dio.value(0)</p>
<p>clk.value(0)</p>
<p>time.sleep(0.0001)</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>clk.value(0)</p>
<p>wr_data &lt;&lt;= 1</p>
<p>return</p>
<p>def start():</p>
<p>global clk,dio</p>
<p>dio.value(1)</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>dio.value(0)</p>
<p>return</p>
<p>def ack():</p>
<p>global clk,dio</p>
<p>dy = 0</p>
<p>clk.value(0)</p>
<p>time.sleep(0.0001)</p>
<p>dio = Pin(dioPin, Pin.IN)</p>
<p>while(dio.value() == 1):</p>
<p>time.sleep(0.0001)</p>
<p>dy += 1</p>
<p>if(dy&gt;5000):</p>
<p>break</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>clk.value(0)</p>
<p>dio = Pin(dioPin, Pin.OUT)</p>
<p>return</p>
<p>def stop():</p>
<p>global clk,dio</p>
<p>dio.value(0)</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>dio.value(1)</p>
<p>return</p>
<p>def displayBit(bit, num):</p>
<p>global ADDR_DIS</p>
<p>if(num &gt; 9 and bit &gt; 4):</p>
<p>return</p>
<p>start()</p>
<p>writeByte(ADDR_DIS)</p>
<p>ack()</p>
<p>writeByte(DisplayCommand)</p>
<p>ack()</p>
<p>stop()</p>
<p>start()</p>
<p>writeByte(DIG[bit-1])</p>
<p>ack()</p>
<p>if(DOT[bit-1] == 1):</p>
<p>writeByte(NUM[num] | 0x80)</p>
<p>else:</p>
<p>writeByte(NUM[num])</p>
<p>ack()</p>
<p>stop()</p>
<p>return</p>
<p>def clearBit(bit):</p>
<p>if(bit &gt; 4):</p>
<p>return</p>
<p>start()</p>
<p>writeByte(ADDR_DIS)</p>
<p>ack()</p>
<p>writeByte(DisplayCommand)</p>
<p>ack()</p>
<p>stop()</p>
<p>start()</p>
<p>writeByte(DIG[bit-1])</p>
<p>ack()</p>
<p>writeByte(0x00)</p>
<p>ack()</p>
<p>stop()</p>
<p>return</p>
<p>def setBrightness(b = BRIGHT_TYPICAL):</p>
<p>global DisplayCommand,brightness</p>
<p>DisplayCommand = (DisplayCommand &amp; 0x0f)+(b&lt;&lt;4)</p>
<p>return</p>
<p>def setMode(segment = 0):</p>
<p>global DisplayCommand</p>
<p>DisplayCommand = (DisplayCommand &amp; 0xf7)+(segment&lt;&lt;3)</p>
<p>return</p>
<p>def displayOnOFF(OnOff = 1):</p>
<p>global DisplayCommand</p>
<p>DisplayCommand = (DisplayCommand &amp; 0xfe)+OnOff</p>
<p>return</p>
<p>def displayDot(bit, OnOff):</p>
<p>if(bit &gt; 4):</p>
<p>return</p>
<p>if(OnOff == 1):</p>
<p>DOT[bit-1] = 1;</p>
<p>else:</p>
<p>DOT[bit-1] = 0;</p>
<p>return</p>
<p>def InitDigitalTube():</p>
<p>setBrightness(2)</p>
<p>setMode(0)</p>
<p>displayOnOFF(1)</p>
<p>for _ in range(4):</p>
<p>clearBit(_)</p>
<p>return</p>
<p>def ShowNum(num): #0~9999</p>
<p>displayBit(1,num%10)</p>
<p>if(num &lt; 10):</p>
<p>clearBit(2)</p>
<p>clearBit(3)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 9 and num &lt; 100):</p>
<p>displayBit(2,num//10%10)</p>
<p>clearBit(3)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 99 and num &lt; 1000):</p>
<p>displayBit(2,num//10%10)</p>
<p>displayBit(3,num//100%10)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 999 and num &lt; 10000):</p>
<p>displayBit(2,num//10%10)</p>
<p>displayBit(3,num//100%10)</p>
<p>displayBit(4,num//1000)</p>
<p>InitDigitalTube()</p>
<p>while True:</p>
<p>adcVal=adc.read()</p>
<p>print(adcVal)</p>
<p>ShowNum(adcVal)</p>
<p>if adcVal &gt; 1000:</p>
<p>buzzer.value(1)</p>
<p>else:</p>
<p>buzzer.value(0)</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**5. Code Explanation**

Define an integer variable adcVal to store the ADC value of the smoke
sensor, and then we display the analog value in the four-digit digital
tube, and then set a threshold, and when the analog value is equal to
the threshold value, the buzzer will beep.

**6. Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. When the concentration of combustible gas
exceeds the threshold value, the active buzzer module will give an
alarm, and the four-digit digital tube will display the concentration
value. Press“Ctrl+C”or click![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

### Project 50: Ultrasonic Radar

![](media/19a7c30e24f0ec39da94912c5535b791.png)

1.  **Description**

![](media/38037219a4908755dbedc422be1ab61b.jpeg)We know that bats use echoes to determine the
direction and the location of their preys. In real life, sonar is used
to detect sounds in the water. Since the attenuation rate of
electromagnetic waves in water is very high, it cannot be used to detect
signals, however, the attenuation rate of sound waves in the water is
much smaller, so sound waves are most commonly used underwater for
observation and measurement.In this experiment, we will use a speaker
module, an RGB module and a 4-digit tube display to make a device for
detection through ultrasonic.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.09028in;height:0.83542in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/4a358f0f161b2e4dcae43f9315902ef3.png" style="width:1.03056in;height:0.56806in" alt="超声波模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/1ef2dd7f7fd91d208e726ef074a02dca.png" style="width:1.02986in;height:0.51667in" alt="8002b功放 喇叭模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/eb9d1b363af72bc105ce38cb9e4d99b1.png" style="width:0.73542in;height:0.98264in" alt="共阴RGB模块" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio HC-SR04 Ultrasonic Sensor*1</td>
<td>Keyestudio 8002b Power Amplifier*1</td>
<td><p>Keyestudio</p>
<p>Common Cathode RGB Module *1</p></td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/8f646a7dfa38852a8eccb5e85eb7341a.png" style="width:1.02917in;height:0.57222in" alt="四位数码管模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:1.02361in;height:0.39861in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.94583in;height:0.44375in" alt="USB线" /></td>
<td></td>
</tr>
<tr class="even">
<td>Keyestudio TM1650 4-Digit Display*1</td>
<td>4P Dupont Wire*3</td>
<td>3P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
<td></td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/3d6e86b75df96354e05447244d2fee68.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin, PWM</p>
<p>import utime</p>
<p># definitions for TM1650</p>
<p>ADDR_DIS = 0x48 #mode command</p>
<p>ADDR_KEY = 0x49 #read key value command</p>
<p># definitions for brightness</p>
<p>BRIGHT_DARKEST = 0</p>
<p>BRIGHT_TYPICAL = 2</p>
<p>BRIGHTEST = 7</p>
<p>on = 1</p>
<p>off = 0</p>
<p># number:0~9</p>
<p>NUM = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f]</p>
<p># DIG = [0x68,0x6a,0x6c,0x6e]</p>
<p>DIG = [0x6e,0x6c,0x6a,0x68]</p>
<p>DOT = [0,0,0,0]</p>
<p>clkPin = 22</p>
<p>dioPin = 21</p>
<p>clk = Pin(clkPin, Pin.OUT)</p>
<p>dio = Pin(dioPin, Pin.OUT)</p>
<p>DisplayCommand = 0</p>
<p>def writeByte(wr_data):</p>
<p>global clk,dio</p>
<p>for i in range(8):</p>
<p>if(wr_data &amp; 0x80 == 0x80):</p>
<p>dio.value(1)</p>
<p>else:</p>
<p>dio.value(0)</p>
<p>clk.value(0)</p>
<p>utime.sleep(0.0001)</p>
<p>clk.value(1)</p>
<p>utime.sleep(0.0001)</p>
<p>clk.value(0)</p>
<p>wr_data &lt;&lt;= 1</p>
<p>return</p>
<p>def start():</p>
<p>global clk,dio</p>
<p>dio.value(1)</p>
<p>clk.value(1)</p>
<p>utime.sleep(0.0001)</p>
<p>dio.value(0)</p>
<p>return</p>
<p>def ack():</p>
<p>global clk,dio</p>
<p>dy = 0</p>
<p>clk.value(0)</p>
<p>utime.sleep(0.0001)</p>
<p>dio = Pin(dioPin, Pin.IN)</p>
<p>while(dio.value() == 1):</p>
<p>utime.sleep(0.0001)</p>
<p>dy += 1</p>
<p>if(dy&gt;5000):</p>
<p>break</p>
<p>clk.value(1)</p>
<p>utime.sleep(0.0001)</p>
<p>clk.value(0)</p>
<p>dio = Pin(dioPin, Pin.OUT)</p>
<p>return</p>
<p>def stop():</p>
<p>global clk,dio</p>
<p>dio.value(0)</p>
<p>clk.value(1)</p>
<p>utime.sleep(0.0001)</p>
<p>dio.value(1)</p>
<p>return</p>
<p>def displayBit(bit, num):</p>
<p>global ADDR_DIS</p>
<p>if(num &gt; 9 and bit &gt; 4):</p>
<p>return</p>
<p>start()</p>
<p>writeByte(ADDR_DIS)</p>
<p>ack()</p>
<p>writeByte(DisplayCommand)</p>
<p>ack()</p>
<p>stop()</p>
<p>start()</p>
<p>writeByte(DIG[bit-1])</p>
<p>ack()</p>
<p>if(DOT[bit-1] == 1):</p>
<p>writeByte(NUM[num] | 0x80)</p>
<p>else:</p>
<p>writeByte(NUM[num])</p>
<p>ack()</p>
<p>stop()</p>
<p>return</p>
<p>def clearBit(bit):</p>
<p>if(bit &gt; 4):</p>
<p>return</p>
<p>start()</p>
<p>writeByte(ADDR_DIS)</p>
<p>ack()</p>
<p>writeByte(DisplayCommand)</p>
<p>ack()</p>
<p>stop()</p>
<p>start()</p>
<p>writeByte(DIG[bit-1])</p>
<p>ack()</p>
<p>writeByte(0x00)</p>
<p>ack()</p>
<p>stop()</p>
<p>return</p>
<p>def setBrightness(b = BRIGHT_TYPICAL):</p>
<p>global DisplayCommand,brightness</p>
<p>DisplayCommand = (DisplayCommand &amp; 0x0f)+(b&lt;&lt;4)</p>
<p>return</p>
<p>def setMode(segment = 0):</p>
<p>global DisplayCommand</p>
<p>DisplayCommand = (DisplayCommand &amp; 0xf7)+(segment&lt;&lt;3)</p>
<p>return</p>
<p>def displayOnOFF(OnOff = 1):</p>
<p>global DisplayCommand</p>
<p>DisplayCommand = (DisplayCommand &amp; 0xfe)+OnOff</p>
<p>return</p>
<p>def displayDot(bit, OnOff):</p>
<p>if(bit &gt; 4):</p>
<p>return</p>
<p>if(OnOff == 1):</p>
<p>DOT[bit-1] = 1;</p>
<p>else:</p>
<p>DOT[bit-1] = 0;</p>
<p>return</p>
<p>def InitDigitalTube():</p>
<p>setBrightness(2)</p>
<p>setMode(0)</p>
<p>displayOnOFF(1)</p>
<p>for _ in range(4):</p>
<p>clearBit(_)</p>
<p>return</p>
<p>def ShowNum(num): #0~9999</p>
<p>displayBit(1,num%10)</p>
<p>if(num &lt; 10):</p>
<p>clearBit(2)</p>
<p>clearBit(3)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 9 and num &lt; 100):</p>
<p>displayBit(2,num//10%10)</p>
<p>clearBit(3)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 99 and num &lt; 1000):</p>
<p>displayBit(2,num//10%10)</p>
<p>displayBit(3,num//100%10)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 999 and num &lt; 10000):</p>
<p>displayBit(2,num//10%10)</p>
<p>displayBit(3,num//100%10)</p>
<p>displayBit(4,num//1000)</p>
<p>pwm_r = PWM(Pin(0))</p>
<p>pwm_g = PWM(Pin(2))</p>
<p>pwm_b = PWM(Pin(15))</p>
<p>pwm_r.freq(1000)</p>
<p>pwm_g.freq(1000)</p>
<p>pwm_b.freq(1000)</p>
<p>def light(red, green, blue):</p>
<p>pwm_r.duty(red)</p>
<p>pwm_g.duty(green)</p>
<p>pwm_b.duty(blue)</p>
<p># Ultrasonic ranging, unit: cm</p>
<p>def getDistance(trigger, echo):</p>
<p># Generates a 10us square wave</p>
<p>trigger.value(0) #A short low level is given beforehand to ensure a clean high pulse:</p>
<p>utime.sleep_us(2)</p>
<p>trigger.value(1)</p>
<p>utime.sleep_us(10)#After pulling high, wait 10 microseconds and immediately set it to low</p>
<p>trigger.value(0)</p>
<p>while echo.value() == 0: #Establish a while loop to detect whether the echo pin value is 0 and record the time at that time</p>
<p>start = utime.ticks_us()</p>
<p>while echo.value() == 1: #Establish a while loop to check whether the echo pin value is 1 and record the time at that time</p>
<p>end = utime.ticks_us()</p>
<p>d = (end - start) * 0.0343 / 2 #The travel time of the sound wave x the speed of sound (343.2 m/s, 0.0343 cm/microsecond), and the distance back and forth divided by 2.</p>
<p>return d</p>
<p># set the pin</p>
<p>trigger = Pin(13, Pin.OUT)</p>
<p>echo = Pin(14, Pin.IN)</p>
<p>buzzer = PWM(Pin(18))</p>
<p>def playtone(frequency):</p>
<p>buzzer.duty(1000)</p>
<p>buzzer.freq(frequency)</p>
<p>def bequiet():</p>
<p>buzzer.duty(0)</p>
<p># main program</p>
<p>InitDigitalTube()</p>
<p>while True:</p>
<p>distance = int(getDistance(trigger, echo))</p>
<p>ShowNum(distance)</p>
<p>if distance &lt;= 10:</p>
<p>playtone(880)</p>
<p>utime.sleep(0.1)</p>
<p>bequiet()</p>
<p>light(1023, 0, 0)</p>
<p>elif distance &lt;= 20:</p>
<p>playtone(532)</p>
<p>utime.sleep(0.2)</p>
<p>bequiet()</p>
<p>light(0, 0, 1023)</p>
<p>else:</p>
<p>light(0, 1023, 0)</p></td>
</tr>
</tbody>
</table>

**5. Code Explanation**

We set sound frequency and light color by adjusting different distance
range.

We can adjust the distance range in the code.

**6. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. When the ultrasonic sensor detects different
distances, the buzzer will produce different frequencies of sound, the
RGB will show different colors, and the measured distances will be
displayed on the 4-digit tube display. Press “Ctrl+C”or click
![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

### Project 51: IR Remote Control

![](media/6e823de7db355fde0bc5fcb7c1cdc705.jpeg)

1.  **Introduction**

In the previous experiments, we learned to turn on or turn off the LED,
adjust the brightness of a light through PWM, and how to use the
infrared receiver module. So in this experiment, we use an infrared
remote control to control an LED module.

When we receive a value, we set the PWM value by the corresponding
button value, thus you can adjust the brightness. Control the LED to
turn on or turn off is in the same way. If we want to use the same
button to control the LED to turn on or turn off, we can achieve it
through the code.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f0ef7a5a2e7eebb09e91f73cb2a6caf3.png" style="width:0.67361in;height:0.89792in" alt="白色LED模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d2903250f8e18898973c545ca497393.png" style="width:0.67639in;height:0.89375in" alt="红外接收模块" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Purple LED Module*1</td>
<td>Keyestudio IR Receiver*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.94583in;height:0.44375in" alt="USB线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/10ccf14d80feba64bba0c1eacd02b09d.png" style="width:1.3in;height:0.62847in" alt="遥控器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td></td>
</tr>
<tr class="even">
<td>Micro USB Cable*1</td>
<td>IR Remote Control*1</td>
<td>3P Dupont Wire*2</td>
<td></td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/e00f371661e0fa08c98e84d3d22a110c.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>import time</p>
<p>from machine import Pin</p>
<p>led = Pin(4, Pin.OUT)</p>
<p>ird = Pin(15,Pin.IN)</p>
<p>act = </p>
<p>def read_ircode(ird):</p>
<p>wait = 1</p>
<p>complete = 0</p>
<p>seq0 = []</p>
<p>seq1 = []</p>
<p>while wait == 1:</p>
<p>if ird.value() == 0:</p>
<p>wait = 0</p>
<p>while wait == 0 and complete == 0:</p>
<p>start = time.ticks_us()</p>
<p>while ird.value() == 0:</p>
<p>ms1 = time.ticks_us()</p>
<p>diff = time.ticks_diff(ms1,start)</p>
<p>seq0.append(diff)</p>
<p>while ird.value() == 1 and complete == 0:</p>
<p>ms2 = time.ticks_us()</p>
<p>diff = time.ticks_diff(ms2,ms1)</p>
<p>if diff &gt; 10000:</p>
<p>complete = 1</p>
<p>seq1.append(diff)</p>
<p>code = ""</p>
<p>for val in seq1:</p>
<p>if val &lt; 2000:</p>
<p>if val &lt; 700:</p>
<p>code += "L"</p>
<p>else:</p>
<p>code += "H"</p>
<p># print(code)</p>
<p>command = ""</p>
<p>for k,v in act.items():</p>
<p>if code == v:</p>
<p>command = k</p>
<p>if command == "":</p>
<p>command = code</p>
<p>return command</p>
<p>flag = False</p>
<p>while True:</p>
<p># global flag</p>
<p>command = read_ircode(ird)</p>
<p>print(command, end = " ")</p>
<p>print(flag, end = " ")</p>
<p>if command == "Ok":</p>
<p>if flag == True:</p>
<p>led.value(1)</p>
<p>flag = False</p>
<p>print("led on")</p>
<p>else:</p>
<p>led.value(0)</p>
<p>flag = True</p>
<p>print("led off")</p>
<p>time.sleep(0.1)</p></td>
</tr>
</tbody>
</table>

**5. Code Explanation**

We define a boolean variable. There are two boolean variables. true
(true) or false (false).

When we press the OK button, the value of infrared reception is OK. At
this time, we need to set a boolean variable flag. When the flag is true
(true), the LED is turned on, and when it is false (false), the LED is
turned off and turned on. After the LED is on and set it to false. We
press the OK key, the LED will be off.

**6. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. Press the OK button of the remote, the LED
will be on; press it again, the LED will be off.

Press“Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to
exit the program.

![](media/ad0be693b3f956103a6fe8c58c3707d6.png)

### Project 52: Heat Dissipation Device

![](media/24a7a2d97a50c2f3fc4ab893d3aee394.jpeg)

**1. Description**

We will use a temperature sensor and some modules to make a smart
cooling device in this experiment. When the ambient temperature is
higher than a certain value, the motor is turned on, thereby reducing
the ambient temperature and achieving the heat dissipation effect. Then
display the temperature value in the four-digit segment display.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6c2548137a8c675141b83227beeb2eb9.png" style="width:0.82917in;height:0.70694in" alt="KS6038 130电机驱动模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f47b077303226cce504ea7734826dfc9.png" style="width:0.94514in;height:0.52569in" alt="四位数码管模块" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio 130 Motor*1</td>
<td>Keyestudio TM16504-Digit Segment Display*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/d892bdfa25f3544ae28aa16d8b1b3c50.png" style="width:0.98056in;height:0.73542in" alt="18B20温度传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:0.98958in;height:0.36042in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.94722in;height:0.41875in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>Keyestudio 18B20 Temperature Sensor*1</td>
<td>3P Dupont Wire*1</td>
<td>4P Dupont Wire*2</td>
<td>Micro USB Cable*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b65d826ca481982fed0212dba2957c7c.jpeg" style="width:1.57361in;height:1.13611in" alt="123" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a815c48437199c6ab79d74cd2d583de0.png" style="width:0.44792in;height:2.0625in" /></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>6 AA Battery Holder*1</td>
<td>AA Battery(not included))*6</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/ab795f487c4b10fe6ff36a82e075475a.png)

**4. Add Library**

Open“Thonny”, click“This computer”→“D:”→“2.
ESP32\_code\_MicroPython”→“lesson 52. heat abstractor”.
Select“ds18x20.py”and“ds18x20.py”，right-click and select“Upload to /”,
waiting for the“ds18x20.py”and“ds18x20.py”to be uploaded to the ESP32.

![](media/6dd994f61c98443dea1f57ec3d2e719d.png)

![](media/71668967db31709ba3d9fd647c6b5dd9.png)

**5.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin</p>
<p>import machine, onewire, ds18x20, time</p>
<p>ds_pin = machine.Pin(13)</p>
<p>ds_sensor = ds18x20.DS18X20(onewire.OneWire(ds_pin))</p>
<p>roms = ds_sensor.scan()</p>
<p>#Two pins of the motor</p>
<p>INA = Pin(15, Pin.OUT) #INA corresponds to IN+</p>
<p>INB = Pin(4, Pin.OUT)#INB corresponds to IN-</p>
<p># definitions for TM1650</p>
<p>ADDR_DIS = 0x48 #mode command</p>
<p>ADDR_KEY = 0x49 #read key value command</p>
<p># definitions for brightness</p>
<p>BRIGHT_DARKEST = 0</p>
<p>BRIGHT_TYPICAL = 2</p>
<p>BRIGHTEST = 7</p>
<p>on = 1</p>
<p>off = 0</p>
<p># number:0~9</p>
<p>NUM = [0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f]</p>
<p># DIG = [0x68,0x6a,0x6c,0x6e]</p>
<p>DIG = [0x6e,0x6c,0x6a,0x68]</p>
<p>DOT = [0,0,0,0]</p>
<p>clkPin = 22</p>
<p>dioPin = 21</p>
<p>clk = Pin(clkPin, Pin.OUT)</p>
<p>dio = Pin(dioPin, Pin.OUT)</p>
<p>DisplayCommand = 0</p>
<p>def writeByte(wr_data):</p>
<p>global clk,dio</p>
<p>for i in range(8):</p>
<p>if(wr_data &amp; 0x80 == 0x80):</p>
<p>dio.value(1)</p>
<p>else:</p>
<p>dio.value(0)</p>
<p>clk.value(0)</p>
<p>time.sleep(0.0001)</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>clk.value(0)</p>
<p>wr_data &lt;&lt;= 1</p>
<p>return</p>
<p>def start():</p>
<p>global clk,dio</p>
<p>dio.value(1)</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>dio.value(0)</p>
<p>return</p>
<p>def ack():</p>
<p>global clk,dio</p>
<p>dy = 0</p>
<p>clk.value(0)</p>
<p>time.sleep(0.0001)</p>
<p>dio = Pin(dioPin, Pin.IN)</p>
<p>while(dio.value() == 1):</p>
<p>time.sleep(0.0001)</p>
<p>dy += 1</p>
<p>if(dy&gt;5000):</p>
<p>break</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>clk.value(0)</p>
<p>dio = Pin(dioPin, Pin.OUT)</p>
<p>return</p>
<p>def stop():</p>
<p>global clk,dio</p>
<p>dio.value(0)</p>
<p>clk.value(1)</p>
<p>time.sleep(0.0001)</p>
<p>dio.value(1)</p>
<p>return</p>
<p>def displayBit(bit, num):</p>
<p>global ADDR_DIS</p>
<p>if(num &gt; 9 and bit &gt; 4):</p>
<p>return</p>
<p>start()</p>
<p>writeByte(ADDR_DIS)</p>
<p>ack()</p>
<p>writeByte(DisplayCommand)</p>
<p>ack()</p>
<p>stop()</p>
<p>start()</p>
<p>writeByte(DIG[bit-1])</p>
<p>ack()</p>
<p>if(DOT[bit-1] == 1):</p>
<p>writeByte(NUM[num] | 0x80)</p>
<p>else:</p>
<p>writeByte(NUM[num])</p>
<p>ack()</p>
<p>stop()</p>
<p>return</p>
<p>def clearBit(bit):</p>
<p>if(bit &gt; 4):</p>
<p>return</p>
<p>start()</p>
<p>writeByte(ADDR_DIS)</p>
<p>ack()</p>
<p>writeByte(DisplayCommand)</p>
<p>ack()</p>
<p>stop()</p>
<p>start()</p>
<p>writeByte(DIG[bit-1])</p>
<p>ack()</p>
<p>writeByte(0x00)</p>
<p>ack()</p>
<p>stop()</p>
<p>return</p>
<p>def setBrightness(b = BRIGHT_TYPICAL):</p>
<p>global DisplayCommand,brightness</p>
<p>DisplayCommand = (DisplayCommand &amp; 0x0f)+(b&lt;&lt;4)</p>
<p>return</p>
<p>def setMode(segment = 0):</p>
<p>global DisplayCommand</p>
<p>DisplayCommand = (DisplayCommand &amp; 0xf7)+(segment&lt;&lt;3)</p>
<p>return</p>
<p>def displayOnOFF(OnOff = 1):</p>
<p>global DisplayCommand</p>
<p>DisplayCommand = (DisplayCommand &amp; 0xfe)+OnOff</p>
<p>return</p>
<p>def displayDot(bit, OnOff):</p>
<p>if(bit &gt; 4):</p>
<p>return</p>
<p>if(OnOff == 1):</p>
<p>DOT[bit-1] = 1;</p>
<p>else:</p>
<p>DOT[bit-1] = 0;</p>
<p>return</p>
<p>def InitDigitalTube():</p>
<p>setBrightness(2)</p>
<p>setMode(0)</p>
<p>displayOnOFF(1)</p>
<p>for _ in range(4):</p>
<p>clearBit(_)</p>
<p>return</p>
<p>def ShowNum(num): #0~9999</p>
<p>displayBit(1,num%10)</p>
<p>if(num &lt; 10):</p>
<p>clearBit(2)</p>
<p>clearBit(3)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 9 and num &lt; 100):</p>
<p>displayBit(2,num//10%10)</p>
<p>clearBit(3)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 99 and num &lt; 1000):</p>
<p>displayBit(2,num//10%10)</p>
<p>displayBit(3,num//100%10)</p>
<p>clearBit(4)</p>
<p>if(num &gt; 999 and num &lt; 10000):</p>
<p>displayBit(2,num//10%10)</p>
<p>displayBit(3,num//100%10)</p>
<p>displayBit(4,num//1000)</p>
<p>InitDigitalTube()</p>
<p>print('Found DS devices: ', roms)</p>
<p>while True:</p>
<p>ds_sensor.convert_temp()</p>
<p>time.sleep_ms(750)</p>
<p>for rom in roms:</p>
<p>value = ds_sensor.read_temp(rom)</p>
<p>print(value)</p>
<p>ShowNum(int(value))</p>
<p>if value &gt; 28:</p>
<p>INA.value(0)</p>
<p>INB.value(1)</p>
<p>else:</p>
<p>INA.value(0)</p>
<p>INB.value(0)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

The setting of variables and the storage of detection values are the
same as what we learned earlier. We also set a temperature threshold and
control the rotation of the motor when the threshold is exceeded, and
then we use the digital tube to display the temperature value.

**7. Test Result**

Wire up and power on. Switch the DIP switch on the ESP32 expansion board
to the ON end. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”, the
code starts executing.We can see the temperature of the current
environment (unit is Celsius) on the four-digit segment display, as
shown in the figure below. If this value exceeds the value we set, the
fan will rotate to dissipate heat. Press“Ctrl+C”or click
![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

### Project 53: Intelligent Entrance Guard System

![](media/6dbae618241cc2dd3060dc4abf94f3a6.jpeg)

1.  **Description**

In this project, we use the RFID522 card swiping module and the servo to
set up an intelligent access control system. The principle is very
simple.We use RFID522 swipe card module, an IC card or key card to
unlock.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/decf08b83c5594f7f1e51f6e93051f4b.png" style="width:1.30208in;height:0.69722in" alt="3 (2)" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/2a40c5c68dc7802d29bcf719bb688f64.png" style="width:1.3in;height:0.81806in" alt="门卡2" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Key*1</td>
<td>IC Card*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a96fbaff92e93d2804dac04e0480dc67.png" style="width:1.18194in;height:0.65972in" alt="RFID刷卡" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b9a96e60ed3aee985db5d4dcaf9bf38b.png" style="width:1.05833in;height:1.05069in" alt="舵机" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:0.91458in;height:0.35625in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:0.94722in;height:0.41875in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>Keyestudio RFID Module*1</td>
<td>Servo*1</td>
<td>4P Dupont Wire*1</td>
<td>Micro USB Cable*1</td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/c8af51059d15f075c781609e64efa43a.png)

**4. Add Library**

Open“Thonny”, click“This computer”→“D:”→“2.
ESP32\_code\_MicroPython”→”lesson 53. Intelligent access control”.
Select“mfrc522\_config.py”，“mfrc522\_i2c.py”and“soft\_iic.py”，right-click
and select“Upload to /”，waiting fof the
“mfrc522\_config.py”，“mfrc522\_i2c.py”and“soft\_iic.py”to be
uploaded to the ESP32.

![](media/88465ea010884daef2bfbf399bafa3ed.png)

![](media/0c2f4bb5aae93d6b536664f539870252.png)

![](media/d68fb1443ca9b36d063c2f15c891cc3f.png)

**5. Test Code：**

**Note: Different RFID-RC522 modules, ID cards and keys may different
uid1 values and uid2 values.** The uID1 and UID2 values of the white
card and key chain read by your RRFID RC522 module can be replaced by
the corresponding values in the program code. If not, click**“Run
current script” to r**un the code may cause your own white card and key
chain to fail to control the servo.  

For example: You can replace the UID1 and UID2 values In the program
code ![](media/80d64ee8ab05fb61cb32d19170295277.png) with your own white card and key chain
values.

<table>
<tbody>
<tr class="odd">
<td><p>from machine import Pin, PWM</p>
<p>import time</p>
<p>from mfrc522_i2c import mfrc522</p>
<p>pwm = PWM(Pin(15))</p>
<p>pwm.freq(50)</p>
<p>'''</p>
<p>Duty cycle corresponding to the Angle</p>
<p>Duty cycle corresponding to the Angle</p>
<p>0°----2.5%----25</p>
<p>45°----5%----51.2</p>
<p>90°----7.5%----77</p>
<p>135°----10%----102.4</p>
<p>180°----12.5%----128</p>
<p>'''</p>
<p>angle_0 = 25</p>
<p>angle_90 = 77</p>
<p>angle_180 = 128</p>
<p>#i2c config</p>
<p>addr = 0x28</p>
<p>scl = 22</p>
<p>sda = 21</p>
<p>rc522 = mfrc522(scl, sda, addr)</p>
<p>rc522.PCD_Init()</p>
<p>rc522.ShowReaderDetails() # Show details of PCD - MFRC522 Card Reader details</p>
<p>uid1 = [237, 247, 148, 90]</p>
<p>uid2 = [76, 9, 107, 110]</p>
<p>pwm.duty(angle_180)</p>
<p>time.sleep(1)</p>
<p>while True:</p>
<p>if rc522.PICC_IsNewCardPresent():</p>
<p>#print("Is new card present!")</p>
<p>if rc522.PICC_ReadCardSerial() == True:</p>
<p>print("Card UID:", end=' ')</p>
<p>print(rc522.uid.uidByte[0 : rc522.uid.size])</p>
<p>if rc522.uid.uidByte[0 : rc522.uid.size] == uid1 or rc522.uid.uidByte[0 : rc522.uid.size] == uid2:</p>
<p>pwm.duty(angle_0)</p>
<p>else :</p>
<p>pwm.duty(angle_180)</p>
<p>time.sleep(500)from machine import Pin, PWM</p>
<p>import time</p>
<p>from mfrc522_i2c import mfrc522</p>
<p>pwm = PWM(Pin(15))</p>
<p>pwm.freq(50)</p>
<p>'''</p>
<p>Duty cycle corresponding to the Angle</p>
<p>Duty cycle corresponding to the Angle</p>
<p>0°----2.5%----25</p>
<p>45°----5%----51.2</p>
<p>90°----7.5%----77</p>
<p>135°----10%----102.4</p>
<p>180°----12.5%----128</p>
<p>'''</p>
<p>angle_0 = 25</p>
<p>angle_90 = 77</p>
<p>angle_180 = 128</p>
<p>#i2c config</p>
<p>addr = 0x28</p>
<p>scl = 22</p>
<p>sda = 21</p>
<p>rc522 = mfrc522(scl, sda, addr)</p>
<p>rc522.PCD_Init()</p>
<p>rc522.ShowReaderDetails() # Show details of PCD - MFRC522 Card Reader details</p>
<p>uid1 = [237, 247, 148, 90]</p>
<p>uid2 = [76, 9, 107, 110]</p>
<p>pwm.duty(angle_180)</p>
<p>time.sleep(1)</p>
<p>while True:</p>
<p>if rc522.PICC_IsNewCardPresent():</p>
<p>#print("Is new card present!")</p>
<p>if rc522.PICC_ReadCardSerial() == True:</p>
<p>print("Card UID:", end=' ')</p>
<p>print(rc522.uid.uidByte[0 : rc522.uid.size])</p>
<p>if rc522.uid.uidByte[0 : rc522.uid.size] == uid1 or rc522.uid.uidByte[0 : rc522.uid.size] == uid2:</p>
<p>pwm.duty(angle_0)</p>
<p>else :</p>
<p>pwm.duty(angle_180)</p>
<p>time.sleep(500)</p></td>
</tr>
</tbody>
</table>

**6. Code Explanation**

In the previous experiment, our RFID module has tested the information
of IC card and key. Then we use this corresponding information to
control the door.

**7. Test Result**

Wire up and power on. Click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”,
the code starts executing. When we use the IC card or blue key to swipe
the card, the shell displays the card and the key information , at the
same time, the servo rotates to the corresponding angle to simulate
opening the door. Press “Ctrl+C”or click
![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart backend”to exit the program.

### Project 54：WIFI Station Mode

1.  **Description**

ESP32 has three different WiFi modes: Station mode, AP mode and
AP+Station mode. All WiFi programming projects must be configured with
WiFi running mode before using, otherwise the WiFi cannot be used. In
this project, we are going to learn the WiFi Station mode of the ESP32.

<table>
<tbody>
<tr class="odd">
<td><strong>Required Components</strong><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/729232b0c2d2c01984808289b222890c.png" style="width:1.8125in;height:0.86458in" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/53f17b0de2d98d4714e8fe9043a346ca.jpeg" style="width:2.43681in;height:1.13472in" alt="IMG_256" /></td>
</tr>
<tr class="even">
<td>USB 线 x1</td>
<td>ESP32*1</td>
</tr>
</tbody>
</table>

**3. Wiring Diagram**

Plug the ESP32 to the USB port of your PC

![](media/53f17b0de2d98d4714e8fe9043a346ca.jpeg)

**4. Component Knowledge**

**Station mode：**

When setting Station mode, the ESP32 is taken as a WiFi client. It can
connect to the router network and communicate with other devices on the
router via a WiFi connection. As shown in the figure below, the PC and
the router have been connected. If the ESP32 wants to communicate with
the PC, the PC and the router need to be connected.

![](media/f74baff97695aa2ee33a8c19370d2547.png)

**5.Test Code：**

![](media/01309c701d6fcf4f443076f8cacdffa1.png)

<table>
<tbody>
<tr class="odd">
<td><p>import time</p>
<p>import network # Import network module.</p>
<p>ssidRouter = 'ChinaNet-2.4G-0DF0' # Enter the router name</p>
<p>passwordRouter = 'ChinaNet@233' # Enter the router password</p>
<p>def STA_Setup(ssidRouter,passwordRouter):</p>
<p>print("Setup start")</p>
<p>sta_if = network.WLAN(network.STA_IF) # Set ESP32 in Station mode.</p>
<p>if not sta_if.isconnected():</p>
<p>print('connecting to',ssidRouter)</p>
<p># Activate ESP32’s Station mode, initiate a connection request to the router</p>
<p># and enter the password to connect.</p>
<p>sta_if.active(True)</p>
<p>sta_if.connect(ssidRouter,passwordRouter)</p>
<p>#Wait for ESP32 to connect to router until they connect to each other successfully.</p>
<p>while not sta_if.isconnected():</p>
<p>pass</p>
<p># Print the IP address assigned to ESP32-WROVER in “Shell”.</p>
<p>print('Connected, IP address:', sta_if.ifconfig())</p>
<p>print("Setup End")</p>
<p>try:</p>
<p>STA_Setup(ssidRouter,passwordRouter)</p>
<p>except:</p>
<p>sta_if.disconnect()</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Since the router name and password are different in various places, so
before running the code, the user needs to enter the correct router name
and password in the red box shown above.

After entering the correct router name and password, click
![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”, the code will start
executing.

The Shell monitor will print the IP address of the ESP32 when connecting
the ESP32 to your router.

![](media/e283d185859ce0a4372c53449bfd03b8.png)

### Project 55：WIFI AP Mode

1.  **Description**

ESP32 has three different WiFi modes: Station mode, AP mode and
AP+Station mode. All WiFi programming projects must be configured with
WiFi running mode before using, otherwise the WiFi cannot be used. In
this project, we are going to learn the WiFi AP mode of the ESP32.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/729232b0c2d2c01984808289b222890c.png" style="width:1.8125in;height:0.86458in" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/53f17b0de2d98d4714e8fe9043a346ca.jpeg" style="width:2.43681in;height:1.13472in" alt="IMG_256" /></td>
</tr>
<tr class="even">
<td>USB 线 x1</td>
<td>ESP32*1</td>
</tr>
</tbody>
</table>

**3. Wiring Diagram**

Plug the ESP32 mainboard to the USB port of your PC

![](media/53f17b0de2d98d4714e8fe9043a346ca.jpeg)

**4. Component Knowledge**

**AP Mode:**

When setting AP mode, a hotspot network will be created, waiting for
other WiFi devices to connect. As shown below;

Take the ESP32 as the hotspot, if a phone or PC needs to communicate
with the ESP32, it must be connected to the ESP32's hotspot.
Communication is only possible after a connection is established via the
ESP32.

![](media/35d90f1ce10814ea1897ba63f8bd7ad9.png)

**5.Test Code：**

![](media/034021f83b237c1264e4677a784b4c2b.png)

<table>
<tbody>
<tr class="odd">
<td><p>import network #Import network module.</p>
<p>#Enter correct router name and password.</p>
<p>ssidAP = 'ESP32_WiFi' #Enter the router name</p>
<p>passwordAP = '12345678' #Enter the router password</p>
<p>local_IP = '192.168.1.147'</p>
<p>gateway = '192.168.1.1'</p>
<p>subnet = '255.255.255.0'</p>
<p>dns = '8.8.8.8'</p>
<p>#Set ESP32 in AP mode.</p>
<p>ap_if = network.WLAN(network.AP_IF)</p>
<p>def AP_Setup(ssidAP,passwordAP):</p>
<p>ap_if.ifconfig([local_IP,gateway,subnet,dns])</p>
<p>print("Setting soft-AP ... ")</p>
<p>ap_if.config(essid=ssidAP,authmode=network.AUTH_WPA_WPA2_PSK, password=passwordAP)</p>
<p>ap_if.active(True)</p>
<p>print('Success, IP address:', ap_if.ifconfig())</p>
<p>print("Setup End\n")</p>
<p>try:</p>
<p>AP_Setup(ssidAP,passwordAP)</p>
<p>except:</p>
<p>print("Failed, please disconnect the power and restart the operation.")</p>
<p>ap_if.disconnect()</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

You can modify the AP name and password or keep them unchanged

Click ![](media/c005d91eb85d5c58566746609ab80254.png)“Run current script”, the code will start
executing. Open the AP function of the ESP32, the Shell monitor will
print the information.

![](media/5be2d032c8adcb2976c1640268919790.png)

Turn on your phone's WiFi search function, then you can see the ssid\_AP
which is called "ESP32\_Wifi" in this code. You can enter the password
"12345678" to connect it, or you can modify its AP name and password by
code.

![](media/3e0ad895bea7f5100cc02a415adcace7.png)

### Project 56：WIFI AP+Station Mode

1.  **Description**

In this project, we are going to learn the AP+Station mode of the ESP32.

**Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/729232b0c2d2c01984808289b222890c.png" style="width:1.8125in;height:0.86458in" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/53f17b0de2d98d4714e8fe9043a346ca.jpeg" style="width:2.43681in;height:1.13472in" alt="IMG_256" /></td>
</tr>
<tr class="even">
<td>USB Cable x1</td>
<td>ESP32*1</td>
</tr>
</tbody>
</table>

**3. Wiring Diagram**

Plug the ESP32 mainboard to the USB port of your PC

![](media/53f17b0de2d98d4714e8fe9043a346ca.jpeg)

**4. Component Knowledge**

**AP+Station mode**

In addition to the AP mode and the Station mode, **AP+Station mode** can
be used at the same time. Turn on the Station mode of the ESP32, connect
it to the router network, and it can communicate with the Internet
through the router. Then turn on the AP mode to create a hotspot
network. Other WiFi devices can be connected to the router network or
the hotspot network to communicate with the ESP32.

**5.Test Code：**

![](media/f2e9eeb897d65975510976b3e178d695.png)

<table>
<tbody>
<tr class="odd">
<td><p>import network #Import network module.</p>
<p>ssidRouter = 'ChinaNet-2.4G-0DF0' #Enter the router name</p>
<p>passwordRouter = 'ChinaNet@233' #Enter the router password</p>
<p>ssidAP = 'ESP32_WiFi'#Enter the AP name</p>
<p>passwordAP = '12345678' #Enter the AP password</p>
<p>local_IP = '192.168.4.147'</p>
<p>gateway = '192.168.1.1'</p>
<p>subnet = '255.255.255.0'</p>
<p>dns = '8.8.8.8'</p>
<p>sta_if = network.WLAN(network.STA_IF)</p>
<p>ap_if = network.WLAN(network.AP_IF)</p>
<p>def STA_Setup(ssidRouter,passwordRouter):</p>
<p>print("Setting soft-STA ... ")</p>
<p>if not sta_if.isconnected():</p>
<p>print('connecting to',ssidRouter)</p>
<p>sta_if.active(True)</p>
<p>sta_if.connect(ssidRouter,passwordRouter)</p>
<p>while not sta_if.isconnected():</p>
<p>pass</p>
<p>print('Connected, IP address:', sta_if.ifconfig())</p>
<p>print("Setup End")</p>
<p>def AP_Setup(ssidAP,passwordAP):</p>
<p>ap_if.ifconfig([local_IP,gateway,subnet,dns])</p>
<p>print("Setting soft-AP ... ")</p>
<p>ap_if.config(essid=ssidAP,authmode=network.AUTH_WPA_WPA2_PSK, password=passwordAP)</p>
<p>ap_if.active(True)</p>
<p>print('Success, IP address:', ap_if.ifconfig())</p>
<p>print("Setup End\n")</p>
<p>try:</p>
<p>AP_Setup(ssidAP,passwordAP)</p>
<p>STA_Setup(ssidRouter,passwordRouter)</p>
<p>except:</p>
<p>sta_if.disconnect()</p>
<p>ap_if.idsconnect()</p></td>
</tr>
</tbody>
</table>

**6. Test Result**

Before running the code, you need to modify ssidRouter, passwordRouter,
ssidAP, and passwordAP. After making sure that the code is modified
correctly, click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”and the
"Shell" window will display the following:

![](media/72c864c57de3f40d2a55ee3c10449898.png)

Then you can see the ssid\_A on the ESP32

![](media/3e0ad895bea7f5100cc02a415adcace7.png)

### Project 57: Comprehensive Experiment

![](media/c92bfcbd1ecd7fe91198066d0c9a4df6.jpeg)

1.  **Introduction**

We did a lot of experiments, and for each one we needed to re-upload the
code, so can we achieve different functions through an experiment? In
this experiment, we will use an external button module to achieve
different functions.

**2.Required Components**

<table>
<tbody>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/c9020c6015e55923afec197ab9d03fae.png" style="width:1.05278in;height:0.48819in" alt="4" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/6d96c844b0260ad712130945d692a7a2.jpeg" style="width:1.34444in;height:1.02986in" alt="ks0465-1" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/f0ef7a5a2e7eebb09e91f73cb2a6caf3.png" style="width:0.67292in;height:0.89722in" alt="白色LED模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/1aafa8910f5184973f1c913c19489fbd.png" style="width:0.67708in;height:0.90347in" alt="单路按键模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/a0eebfcd8f84c3fbac526e9910e66692.png" style="width:0.66319in;height:0.88472in" alt="旋转电位器传感器" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/b62846d9a80a7e7aed5ffbef0caedf7c.png" style="width:0.64167in;height:0.92083in" alt="避障传感器" /></td>
</tr>
<tr class="even">
<td>ESP32 Board*1</td>
<td>ESP32 Expansion Board*1</td>
<td>Keyestudio Purple LED Module*1</td>
<td>Keyestudio Button Module*1</td>
<td>Keyestudio Rotary Potentiometer*1</td>
<td>Keyestudio Obstacle Avoidance Sensor*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/3538e48e4603a0afb9ae18197769c3ef.png" style="width:0.89375in;height:0.67569in" alt="单路巡线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/fb4fa5fdd5689ded9c213ba5ceb34c0d.png" style="width:1.04097in;height:0.51319in" alt="摇杆模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/4a358f0f161b2e4dcae43f9315902ef3.png" style="width:0.97847in;height:0.53958in" alt="超声波模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/51729b3ba2184cf0ca0d3242199731ad.png" style="width:0.65972in;height:0.88125in" alt="共阴RGB模块" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/04f2996e6e2b0d8d4b5158728a23e905.png" style="width:0.88472in;height:0.66875in" alt="33.温湿度" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/edbfec59fe015bd9987e4b4d542b466d.png" style="width:1.07361in;height:0.42778in" alt="USB线" /></td>
</tr>
<tr class="even">
<td>Keyestudio Line Tracking Sensor*1</td>
<td>Keyestudio Joystick Module*1</td>
<td>Keyestudio HHC-SR04 Ultrasonic Sensor *1</td>
<td>Keyestudio Common Cathode RGB Module *1</td>
<td>Keyestudio XHT11 Temperature and Humidity Sensor *1</td>
<td>Micro USB Cable*1</td>
</tr>
<tr class="odd">
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/0d81e07a0f67700c5a396fc7e1e614e1.jpeg" style="width:1.10069in;height:0.40069in" alt="3p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/269c154eda332be03643bada56070124.jpeg" style="width:1.14722in;height:0.44722in" alt="4p线" /></td>
<td><img src="https://raw.githubusercontent.com/keyestudio/KS5005-KS5006-Keyestudio-ESP32-37-in-1-Sensor-Kit-Python/master/media/fc3fd9c0110b04d1af77a2ff8c01a10a.png" style="width:1.10417in;height:0.46319in" alt="5p线" /></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>3P Dupont Wire*6</td>
<td>4P Dupont Wire*2</td>
<td>5P Dupont Wire*1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

**3.Wiring Diagram**

![](media/9a02c45a8c8689060b102bdc742432f2.png)

**4.Test Code：**

<table>
<tbody>
<tr class="odd">
<td><p>from machine import ADC, Pin, PWM</p>
<p>import time</p>
<p>import machine</p>
<p>import random</p>
<p>import dht</p>
<p>pwm_r = PWM(Pin(4))</p>
<p>pwm_g = PWM(Pin(0))</p>
<p>pwm_b = PWM(Pin(2))</p>
<p>pwm_r.freq(1000)</p>
<p>pwm_g.freq(1000)</p>
<p>pwm_b.freq(1000)</p>
<p>DHT = dht.DHT11(machine.Pin(15))</p>
<p>potentiometer_adc=ADC(Pin(33))</p>
<p>potentiometer_adc.atten(ADC.ATTN_11DB)</p>
<p>potentiometer_adc.width(ADC.WIDTH_12BIT)</p>
<p>button = Pin(23, Pin.IN)</p>
<p>led = PWM(Pin(5))</p>
<p>led.freq(1000)</p>
<p>tracking = Pin(14, Pin.IN, Pin.PULL_UP)</p>
<p>button_z=Pin(32,Pin.IN,Pin.PULL_UP)</p>
<p>rocker_x=ADC(Pin(35))</p>
<p>rocker_y=ADC(Pin(34))</p>
<p>rocker_x.atten(ADC.ATTN_11DB)</p>
<p>rocker_y.atten(ADC.ATTN_11DB)</p>
<p>rocker_x.width(ADC.WIDTH_12BIT)</p>
<p>rocker_y.width(ADC.WIDTH_12BIT)</p>
<p>avoid = Pin(27, Pin.IN)</p>
<p># Set ultrasonic pins</p>
<p>trigger = Pin(13, Pin.OUT)</p>
<p>echo = Pin(12, Pin.IN)</p>
<p>def light(red, green, blue):</p>
<p>pwm_r.duty(red)</p>
<p>pwm_g.duty(green)</p>
<p>pwm_b.duty(blue)</p>
<p># Ultrasonic ranging, unit: cm</p>
<p>def getDistance(trigger, echo):</p>
<p># Generates a 10us square wave</p>
<p>trigger.value(0) #A short low level is given beforehand to ensure a clean high pulse:</p>
<p>time.sleep_us(2)</p>
<p>trigger.value(1)</p>
<p>time.sleep_us(10)#After pulling high, wait 10 microseconds and immediately set it to low</p>
<p>trigger.value(0)</p>
<p>while echo.value() == 0: #Establish a while loop to detect whether the echo pin value is 0 and record the time at that time</p>
<p>start = time.ticks_us()</p>
<p>while echo.value() == 1: #Establish a while loop to check whether the echo pin value is 1 and record the time at that time</p>
<p>end = time.ticks_us()</p>
<p>d = (end - start) * 0.0343 / 2 #The travel time of the sound wave x the speed of sound (343.2 m/s, 0.0343 cm/microsecond), and the distance back and forth divided by 2</p>
<p>return d</p>
<p>keys = 0</p>
<p>nums = 0</p>
<p>print(keys % 8)</p>
<p>def toggle_handle(pin):</p>
<p>global keys</p>
<p>keys += 1</p>
<p>print(keys % 7)</p>
<p>button.irq(trigger = Pin.IRQ_FALLING, handler = toggle_handle)</p>
<p>def showRGB():</p>
<p>R = random.randint(0,1023)</p>
<p>G = random.randint(0,1023)</p>
<p>B = random.randint(0,1023)</p>
<p>light(R, G, B)</p>
<p>time.sleep(0.3)</p>
<p>def showxht11():</p>
<p>DHT.measure()</p>
<p>print('temperature:',DHT.temperature(),'℃','humidity:',DHT.humidity(),'%')</p>
<p>time.sleep(1)</p>
<p>def showtracking():</p>
<p>if tracking.value() == 0:</p>
<p>print("0 White") #Press to print the corresponding information.</p>
<p>else:</p>
<p>print("1 Black")</p>
<p>time.sleep(0.1) #delay 0.1s</p>
<p>def showJoystick():</p>
<p>B_value = button_z.value()</p>
<p>X_value = rocker_x.read()</p>
<p>Y_value = rocker_y.read()</p>
<p>print("button:", end = " ")</p>
<p>print(B_value, end = " ")</p>
<p>print("X:", end = " ")</p>
<p>print(X_value, end = " ")</p>
<p>print("Y:", end = " ")</p>
<p>print(Y_value)</p>
<p>time.sleep(0.1)</p>
<p>def adjustLight():</p>
<p>pot_value = potentiometer_adc.read()</p>
<p>print(pot_value)</p>
<p>led.duty(pot_value)</p>
<p>time.sleep(0.1)</p>
<p>def showAvoid():</p>
<p>if avoid.value() == 0:</p>
<p>print("There are obstacles")</p>
<p>else:</p>
<p>print("All going well")</p>
<p>time.sleep(0.1)</p>
<p>def showDistance():</p>
<p>distance = getDistance(trigger, echo)</p>
<p>print("The distance is ： cm".format(distance))</p>
<p>time.sleep(0.1)</p>
<p>while True:</p>
<p>nums = keys % 7 #number of keystrokes mod 7 to get 0, 1, 2, 3, 4, 5, 6</p>
<p>if nums == 0: #According to RGB</p>
<p>showRGB()</p>
<p>elif nums == 1: #Displays the high and low level of the tracking sensor</p>
<p>showtracking()</p>
<p>elif nums == 2: #Display temperature and humidity</p>
<p>showxht11()</p>
<p>elif nums == 3: #Displays the rocker value</p>
<p>showJoystick()</p>
<p>elif nums == 4: #The potentiometer adjusts the LED</p>
<p>adjustLight()</p>
<p>elif nums == 5: #Display obstacle information</p>
<p>showAvoid()</p>
<p>elif nums == 6: #Display ultrasonic ranging value</p>
<p>showDistance()</p></td>
</tr>
</tbody>
</table>

**Code Explanation**

Calculate how many times the button is pressed, divide it by 7, and get
the remainder which is 0, 1 2, 3, 4, 5 , 6. According to different
remainders, construct seven unique functions to realize different
functions.

We can add or reduce sensors or modules.

**Test Result**

Wire up, power on and click ![](media/da852227207616ccd9aff28f19e02690.png)“Run current script”.
At the beginning, the number of keys is 0, the remainder is 0, and the
four lamp beads on the RGB module flash with random colors.

![](media/2b5ff126000d0182b9b3e6bd70de3bab.png)

Press a button, the RGB stops flashing, press once, the remainder is 1.
The function of the experiment is to track the sensor according to black
and white objects read high and low levels, the following information is
displayed.

![](media/7365faf1c84b5d0168bc8b7485b436cb.png)

Press the key twice, the time of pressing buttons is 2 and the remainder
is 2. Read temperature and humidity values. As shown below;

![](media/b326a19e887434924c1df74346a1c9aa.png)

Press the key again, the time of pressing buttons is 3 and the remainder
is 3. Read digital values at x, y and z axis of the joystick module. As
shown below;

![](media/21a31fba315990014bd6e62a4e1b78f6.png)

Press the key for the fourth time, the remainder is 4. Then the
potentiometer can adjust the PWM value at the GPI05 port to control LED
brightness of the purple LED

Press the key for the fifth time, the remainder is 5. Then the obstacle
avoidance sensor can detect obstacles, as shown below;

![](media/40e0ba1935c2ba87613d0f94fc30b830.png)

Press the key for the sixth time, the remainder is 6. Then the
ultrasonic sensor can detect distance away from obstacles, as shown
below;

![](media/b7ebf58db51f94d52c4e843531beb348.png)

Press the key for seventh time and the remainder is 0. The RGB will
flash again. Keep pressing the key, functions will change.
Press“Ctrl+C”or click ![](media/27451c8a9c13e29d02bc0f5831cfaf1f.png)“Stop/Restart
backend”to exit the program.

## 5. Resources

https://fs.keyestudio.com/KS5005-5006


